
Properties config = OAuthUtils.getClientConfigProps    (OAuthConstants.CONFIG_FILE_PATH);
String resourceServerUrl = config.getProperty(OAuthConstants.RESOURCE_SERVER_URL);      
String username = config.getProperty(OAuthConstants.USERNAME);
String password = config.getProperty(OAuthConstants.PASSWORD);
String grantType = config.getProperty(OAuthConstants.GRANT_TYPE);
String authenticationServerUrl = config
        .getProperty(OAuthConstants.AUTHENTICATION_SERVER_URL);
                
 if (!OAuthUtils.isValid(username)
   || !OAuthUtils.isValid(password)
   || !OAuthUtils.isValid(authenticationServerUrl)
   || !OAuthUtils.isValid(grantType)) {
 System.out
       .println("Please provide valid values for username, password,
                       authentication server url and grant type");
 System.exit(0);
   
  }
  
 
if (!OAuthUtils.isValid(resourceServerUrl)) {
// Resource server url is not valid.
//Only retrieve the access token
System.out.println("Retrieving Access Token");
OAuth2Details oauthDetails = OAuthUtils.createOAuthDetails(config);
String accessToken = OAuthUtils.getAccessToken(oauthDetails);
System.out
.println("Successfully retrieved Access token
 for Password Grant: " + accessToken);
}
else {
// Response from the resource server must be in Json or
//Urlencoded or xml
System.out.println("Resource endpoint url: " + resourceServerUrl);
System.out.println("Attempting to retrieve protected resource");
OAuthUtils.getProtectedResource(config);
     }
	 
	 =====================
	 
	 String resourceURL =
config.getProperty(OAuthConstants.RESOURCE_SERVER_URL);
OAuth2Details oauthDetails = createOAuthDetails(config);
HttpGet get = new HttpGet(resourceURL);
get.addHeader(OAuthConstants.AUTHORIZATION,
getAuthorizationHeaderForAccessToken(oauthDetails
.getAccessToken()));
DefaultHttpClient client = new DefaultHttpClient();
HttpResponse response = null;
int code = -1;
  try {
    response = client.execute(get);
    code = response.getStatusLine().getStatusCode();
    if (code >= 400) {
      // Access token is invalid or expired.
      // Regenerate the access token
      System.out.println("Access token is invalid
      or expired. Regenerating access token....");
      String accessToken = getAccessToken(oauthDetails);
      if (isValid(accessToken)) {
    // update the access token
      // System.out.println("New access token: " + accessToken);
      oauthDetails.setAccessToken(accessToken);
      get.removeHeaders(OAuthConstants.AUTHORIZATION);
      get.addHeader(OAuthConstants.AUTHORIZATION,
      getAuthorizationHeaderForAccessToken(oauthDetails
    .getAccessToken()));
      get.releaseConnection();
      response = client.execute(get);
      code = response.getStatusLine().getStatusCode();
    if (code >= 400) {
    throw new RuntimeException("Could not
  access protected resource.
  Server returned http code: "+ code);
 
     }
 
   } else {
    throw new RuntimeException("Could not
       regenerate access token");
    }
 
 }
 
 ============================
 
 MultivaluedMap formData = new MultivaluedMapImpl();
 formData.add("name1", "val1"); formData.add("name2", "val2"); 
ClientResponse response = webResource.type("application/x-www-form-urlencoded").post(ClientResponse.class, formData);

MultivaluedMap formData = new MultivaluedMapImpl();
formData.add("name1", "val1");
formData.add("name2", "val2");
ClientResponse response = webResource.type("application/x-www-form-urlencoded") .post(ClientResponse.class, formData);


@Override
  public synchronized  String getApiKey() {
    if(key == null) {
      final String unencodedCredentials = email + ":" + password;
      final String encodedCredentials = javax.xml.bind.DatatypeConverter.printBase64Binary(unencodedCredentials.getBytes());
      final WebResource resource = super.getRawWebResource();
      final ClientResponse response = resource.path("authenticate")
                                              .path("baseauth")
                                              .header("Authorization", encodedCredentials)
                                              .get(ClientResponse.class);
      if(response.getStatus() != 200) {
        throw new RuntimeException("Failed to build Galaxy API key for supplied user e-mail and password.");
      }
      final Map<String, Object> responseObjects = response.getEntity(Map.class);
      key = responseObjects.get("api_key").toString();
    }
    return key;
  }
   // Authorize (allow) all domains to consume the content
        response.addHeader("Access-Control-Allow-Origin", "http://localhost:3000");
        response.addHeader("Access-Control-Allow-Methods", "GET");
        response.addHeader("Access-Control-Allow-Headers", "*");
		
		
		URL url = new URL("https://www.googleapis.com/tasks/v1/users/@me/lists?key=" + your_api_key);
URLConnection conn = (HttpURLConnection) url.openConnection();
conn.addRequestProperty("client_id", your client id);
conn.addRequestProperty("client_secret", your client secret);
conn.setRequestProperty("Authorization", "OAuth " + token);

OkHttpClient client = new OkHttpClient();

MediaType mediaType = MediaType.parse("application/x-www-form-urlencoded");
RequestBody body = RequestBody.create(mediaType, "grant_type=client_credentials");
Request request = new Request.Builder()
  .url("https://dev-api.bancoazteca.com.mx/oauth2/v1/token")
  .post(body)
  .addHeader("Content-Type", "application/x-www-form-urlencoded")
  .addHeader("cache-control", "no-cache")
  .addHeader("Postman-Token", "e58ddeef-fe6e-4936-9a4f-23eeb164a84b")
  .build();

Response response = client.newCall(request).execute();

// From the OAuth2 RFC, client ID and secret should be encoded prior to concatenation and
        // conversion to Base64: https://tools.ietf.org/html/rfc6749#section-2.3.1
        String encodedClientId = UriUtil.formUrlEncodeValue(clientId);
        String encodedClientSecret = UriUtil.formUrlEncodeValue(mClientSecret);
        String credentials = encodedClientId + ":" + encodedClientSecret;
        String basicAuth = Base64.encodeToString(credentials.getBytes(), Base64.NO_WRAP);
        return Collections.singletonMap("Authorization", "Basic " + basicAuth);
		
		
		
		
		String credentials = clientId + ":" + mClientSecret;
        String basicAuth = Base64.encodeToString(credentials.getBytes(), Base64.NO_WRAP);
        return Collections.singletonMap("Authorization", "Basic " + basicAuth);


===============









import java.io.IOException;
import java.util.Arrays;

import org.apache.commons.codec.binary.Base64;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.servlet.ModelAndView;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.oauth.model.Employee;


@Controller
public class EmployeeController {

	@RequestMapping(value = "/getEmployees", method = RequestMethod.GET)
	public ModelAndView getEmployeeInfo() {
		return new ModelAndView("getEmployees");
	}

	@RequestMapping(value = "/showEmployees", method = RequestMethod.GET)
	public ModelAndView showEmployees(@RequestParam("code") String code) throws JsonProcessingException, IOException {
		ResponseEntity<String> response = null;
		System.out.println("Authorization Ccode------" + code);

		RestTemplate restTemplate = new RestTemplate();

		String credentials = "javainuse:secret";
		String encodedCredentials = new String(Base64.encodeBase64(credentials.getBytes()));

		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
		headers.add("Authorization", "Basic " + encodedCredentials);

		HttpEntity<String> request = new HttpEntity<String>(headers);

		String access_token_url = "http://localhost:8080/oauth/token";
		access_token_url += "?code=" + code;
		access_token_url += "&grant_type=authorization_code";
		access_token_url += "&redirect_uri=http://localhost:8090/showEmployees";

		response = restTemplate.exchange(access_token_url, HttpMethod.POST, request, String.class);

		System.out.println("Access Token Response ---------" + response.getBody());

		// Get the Access Token From the recieved JSON response
		ObjectMapper mapper = new ObjectMapper();
		JsonNode node = mapper.readTree(response.getBody());
		String token = node.path("access_token").asText();

		String url = "http://localhost:8080/user/getEmployeesList";

		// Use the access token for authentication
		HttpHeaders headers1 = new HttpHeaders();
		headers1.add("Authorization", "Bearer " + token);
		HttpEntity<String> entity = new HttpEntity<>(headers1);

		ResponseEntity<Employee[]> employees = restTemplate.exchange(url, HttpMethod.GET, entity, Employee[].class);
		System.out.println(employees);
		Employee[] employeeArray = employees.getBody();

		ModelAndView model = new ModelAndView("showEmployees");
		model.addObject("employees", Arrays.asList(employeeArray));
		return model;
	}
}
===============================================
Authorization Code Grant Type

import javax.net.ssl.HttpsURLConnection;
import java.io.*;
import java.net.URL;
import java.util.Base64;
private static final String clientId = "";//clientId
private static final String callBackUrl = "";//The url defined in WSO2
private static final String authorizeUrl = "https://api.byu.edu/authorize";
String authorizationRedirect = getAuthGrantType(callBackUrl);
private static String getAuthGrantType(String callbackURL){
    return authorizeUrl + "?response_type=code&client_id=" + clientId + "&redirect_uri=" + callbackURL + "&scope=openid";
}
//Wait for user to logIn and then
//getAccessToken(with the authorizationCode from header name 'authorization_code', callbackUrl);
//Then call useBearerToken('access_token')
private static void useBearerToken(String bearerToken) {
    BufferedReader reader = null;
    try {
        URL url = new URL("https://api.byu.edu:443/echo/v1/status?test=testing");
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        connection.setRequestProperty("Authorization", "Bearer " + bearerToken);
        connection.setDoOutput(true);
        connection.setRequestMethod("GET");
        reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line = null;
        StringWriter out = new StringWriter(connection.getContentLength() > 0 ? connection.getContentLength() : 2048);
        while ((line = reader.readLine()) != null) {
            out.append(line);
        }
        String response = out.toString();
        System.out.println(response);
    } catch (Exception e) {

    }
}
Implicit Grant Type

import javax.net.ssl.HttpsURLConnection;
import java.io.*;
import java.net.URL;
import java.util.Base64;

private static final String authorizeUrl = "https://api.byu.edu/authorize";
private static final String clientId = "";//clientId
private static final String callBackUrl = "";
getImplicitGrantType(callBackUrl);
private static String getImplicitGrantType(String callbackURL) {
    return authorizeUrl + "?response_type=token&client_id=" + clientId + "&redirect_uri=" + callbackURL + "&scope=openid";
}
//Wait for user to logIn and then make your call like useBearerToken(with Token from header name 'access_token')
private static void useBearerToken(String bearerToken) {
    BufferedReader reader = null;
    try {
        URL url = new URL("https://api.byu.edu:443/echo/v1/status?test=testing");
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        connection.setRequestProperty("Authorization", "Bearer " + bearerToken);
        connection.setDoOutput(true);
        connection.setRequestMethod("GET");
        reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line = null;
        StringWriter out = new StringWriter(connection.getContentLength() > 0 ? connection.getContentLength() : 2048);
        while ((line = reader.readLine()) != null) {
            out.append(line);
        }
        String response = out.toString();
        System.out.println(response);
    } catch (Exception e) {

    }
}


Resource Owner Password Credentials Grant Type

import javax.net.ssl.HttpsURLConnection;
import java.io.*;
import java.net.URL;
import java.util.Base64;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
private static final Pattern pat = Pattern.compile(".*\"access_token\"\\s*:\\s*\"([^\"]+)\".*");
private static final String clientId = "";//clientId
private static final String clientSecret = "";//client secret
private static final String tokenUrl = "https://api.byu.edu/token";
private static final String auth = clientId + ":" + clientSecret;
private static final String authentication = Base64.getEncoder().encodeToString(auth.getBytes());
//Username is netId for the person making the call and the password is there password
private static String getResourceCredentials(String userName, String password) {
    String content = "grant_type=password&username=" + userName + "&password=" + password;
    BufferedReader reader = null;
    HttpsURLConnection connection = null;
    String returnValue = "";
    try {
        URL url = new URL(tokenUrl);
        connection = (HttpsURLConnection) url.openConnection();
        connection.setRequestMethod("POST");
        connection.setDoOutput(true);
        connection.setRequestProperty("Authorization", "Basic " + authentication);
        connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        connection.setRequestProperty("Accept", "application/json");
        PrintStream os = new PrintStream(connection.getOutputStream());
        os.print(content);
        os.close();
        reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line = null;
        StringWriter out = new StringWriter(connection.getContentLength() > 0 ? connection.getContentLength() : 2048);
        while ((line = reader.readLine()) != null) {
            out.append(line);
        }
        String response = out.toString();
        Matcher matcher = pat.matcher(response);
        if (matcher.matches() && matcher.groupCount() > 0) {
            returnValue = matcher.group(1);
        }
    } catch (Exception e) {
        System.out.println("Error : " + e.getMessage());
    } finally {
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
            }
        }
        connection.disconnect();
    }
    return returnValue;
}
private static void usePersonSummary(String resourceOwner, String netId) {
    BufferedReader reader = null;
    try {
        URL url = new URL("https://api.byu.edu:443/domains/legacy/identity/person/personsummary/v1/" + netId);
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        connection.setRequestProperty("Authorization", "Bearer " + resourceOwner);
        connection.setDoOutput(true);
        connection.setRequestMethod("GET");
        reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line = null;
        StringWriter out = new StringWriter(connection.getContentLength() > 0 ? connection.getContentLength() : 2048);
        while ((line = reader.readLine()) != null) {
            out.append(line);
        }
        String response = out.toString();
        System.out.println(response);
    } catch (Exception e) {

    }
}
Client Credentials Grant Type

import javax.net.ssl.HttpsURLConnection;
import java.io.*;
import java.net.URL;
import java.util.Base64;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
private static final Pattern pat = Pattern.compile(".*\"access_token\"\\s*:\\s*\"([^\"]+)\".*");
private static final String clientId = "";//clientId
private static final String clientSecret = "";//client secret
private static final String tokenUrl = "https://api.byu.edu/token";
private static final String auth = clientId + ":" + clientSecret;
private static final String authentication = Base64.getEncoder().encodeToString(auth.getBytes());
private static String getClientCredentials() {
    String content = "grant_type=client_credentials";
    BufferedReader reader = null;
    HttpsURLConnection connection = null;
    String returnValue = "";
    try {
        URL url = new URL(tokenUrl);
        connection = (HttpsURLConnection) url.openConnection();
        connection.setRequestMethod("POST");
        connection.setDoOutput(true);
        connection.setRequestProperty("Authorization", "Basic " + authentication);
        connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        connection.setRequestProperty("Accept", "application/json");
        PrintStream os = new PrintStream(connection.getOutputStream());
        os.print(content);
        os.close();
        reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line = null;
        StringWriter out = new StringWriter(connection.getContentLength() > 0 ? connection.getContentLength() : 2048);
        while ((line = reader.readLine()) != null) {
            out.append(line);
        }
        String response = out.toString();
        Matcher matcher = pat.matcher(response);
        if (matcher.matches() && matcher.groupCount() > 0) {
            returnValue = matcher.group(1);
        }
    } catch (Exception e) {
        System.out.println("Error : " + e.getMessage());
    } finally {
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
            }
        }
        connection.disconnect();
    }
    return returnValue;
}
private static void useBearerToken(String bearerToken) {
    BufferedReader reader = null;
    try {
        URL url = new URL("https://api.byu.edu:443/echo/v1/status?test=testing");
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        connection.setRequestProperty("Authorization", "Bearer " + bearerToken);
        connection.setDoOutput(true);
        connection.setRequestMethod("GET");
        reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line = null;
        StringWriter out = new StringWriter(connection.getContentLength() > 0 ? connection.getContentLength() : 2048);
        while ((line = reader.readLine()) != null) {
            out.append(line);
        }
        String response = out.toString();
        System.out.println(response);
    } catch (Exception e) {

    }
}
======================

HttpPost post = new HttpPost(
oauthDetails.getAuthenticationServerUrl());
String clientId = oauthDetails.getClientId();
String clientSecret = oauthDetails.getClientSecret();
String scope = oauthDetails.getScope();
 
List<BasicNameValuePair> parametersBody =
new ArrayList<BasicNameValuePair>();
parametersBody.add(new BasicNameValuePair(OAuthConstants.GRANT_TYPE,
oauthDetails.getGrantType()));
parametersBody.add(new BasicNameValuePair(OAuthConstants.USERNAME,
oauthDetails.getUsername()));
parametersBody.add(new BasicNameValuePair(OAuthConstants.PASSWORD,
oauthDetails.getPassword()));
 
if (isValid(clientId)) {
   parametersBody.add(new BasicNameValuePair
     (OAuthConstants.CLIENT_ID,clientId));
 }
if (isValid(clientSecret)) {
   parametersBody.add(new BasicNameValuePair(
   OAuthConstants.CLIENT_SECRET, clientSecret));
 }
if (isValid(scope)) {
   parametersBody.add(new BasicNameValuePair
     (OAuthConstants.SCOPE,scope));
 }
 
DefaultHttpClient client = new DefaultHttpClient();
HttpResponse response = null;
String accessToken = null;
  try {
   post.setEntity(new UrlEncodedFormEntity(parametersBody,
      HTTP.UTF_8));
    
   response = client.execute(post);
   int code = response.getStatusLine().getStatusCode();
   if (code >= 400) {
   System.out.println("Authorization
      server expects Basic authentication");
   // Add Basic Authorization header
   post.addHeader(
   OAuthConstants.AUTHORIZATION,
   getBasicAuthorizationHeader(oauthDetails.getUsername(),
   oauthDetails.getPassword()));
   System.out.println("Retry with login credentials");
   post.releaseConnection();
   response = client.execute(post);
   code = response.getStatusLine().getStatusCode();
   if (code >= 400) {
   System.out.println("Retry with client credentials");
   post.removeHeaders(OAuthConstants.AUTHORIZATION);
   post.addHeader(
   OAuthConstants.AUTHORIZATION,
      getBasicAuthorizationHeader(
    oauthDetails.getClientId(),
   oauthDetails.getClientSecret()));
   post.releaseConnection();
   response = client.execute(post);
   code = response.getStatusLine().getStatusCode();
   if (code >= 400) {
   throw new RuntimeException(
   "Could not retrieve access token for user: "
   oauthDetails.getUsername());
      }
       }
     }
   Map<String, String> map = handleResponse(response);
   accessToken = map.get(OAuthConstants.ACCESS_TOKEN);
   } catch (ClientProtocolException e) {
           // TODO Auto-generated catch block
           e.printStackTrace();
   } catch (IOException e) {
           // TODO Auto-generated catch block
           e.printStackTrace();
   }
 
   return accessToken;
   
   ==========












String grant_type = "client_credentials";    
String scope = "generate-ads-output";    

httpPost.addHeader("Content-Type", "application/x-www-form-urlencoded");    
StringEntity input = null;    
try {    
input = new StringEntity("grant_type=" + grant_type);     

    httpPost.setEntity(input);    
 } 
 catch (UnsupportedEncodingException e) {    
        e.printStackTrace();    
   }
   
   
   try {
        OAuthClient client = new OAuthClient(new URLConnectionClient());

        OAuthClientRequest request = OAuthClientRequest.tokenLocation(TOKEN_REQUEST_URL)
                .setGrantType(GrantType.CLIENT_CREDENTIALS)
                .setClientId(CLIENT_ID)
                .setClientSecret(CLIENT_SECRET)
                .setScope(SCOPE)
                .buildBodyMessage();

        System.out.println(request.getBody());

        String token = client.accessToken(request, OAuth.HttpMethod.POST, OAuthJSONAccessTokenResponse.class).getAccessToken();
        System.out.println(token);
    } catch (Exception exn) {
        exn.printStackTrace();
    }
	
	=====================================================================
	
	import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import org.apache.http.Header;
import org.apache.http.HttpResponse;
import org.apache.http.client.CookieStore;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.impl.client.HttpClientBuilder;

public class REST_CreateSession {
	public static void main(String[] args) {
		//CONFIG PARAMETERS:
		//BEGIN------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		String baseRestURL = "https://env-73627.customer.cloud.microstrategy.com/MicroStrategyLibrary"";
		String cubeName = "MyCube";
		String username = "steve"; 
		String password = "";
		String projectID = "B7CA92F04B9FAE8D941C3E9B7E0CD754"; 
		String updatePolicy = "add";
		//END------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		
		//Create HTTPClient - Used to make Request to API
		HttpClient httpClient = null;
		CookieStore httpCookieStore = new BasicCookieStore();
		HttpClientBuilder builder = HttpClientBuilder.create().setDefaultCookieStore(httpCookieStore);
		httpClient = builder.build();
		
		//Create Session using /api/auth/login
		String authToken = createAuthToken(baseRestURL, httpClient, username, password);
		System.out.println("Auth Token: " + authToken);
		
		if(authToken == null){
			System.out.println("Error: Unable to generate authToken - check to see if server is running");
			return;
		}
	}
		
	//Creates an AuthToken
	public static String createAuthToken(String baseRestURL, HttpClient httpClient, String username, String password){
		String APIPath = "/api/auth/login";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println("REST API URL: " + completeRestURL);
	    
		// Define the server endpoint to send the HTTP request to
	    URL serverUrl;
		try {
			serverUrl = new URL(completeRestURL);
		
			HttpPost httpRequest = new HttpPost(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			StringEntity body =new StringEntity("{\"username\": \""+username+"\",\"password\": \""+password+"\",\"loginMode\": 1,\"applicationType\": 35}");
			httpRequest.setEntity(body);
			 
			HttpResponse response = httpClient.execute(httpRequest);
			
			Header[] headers = (Header[]) response.getAllHeaders();
			for (int i = 0; i < headers.length; i++){
				Header header = headers[i];
				//System.out.println(header.getName() + " : " + header.getValue());
				if (header.getName().equalsIgnoreCase("X-MSTR-AuthToken")){
					return header.getValue();
				}
			}
			
			return null;
			
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}


}
	
	
	=============
	
	response.addHeader("Access-Control-Allow-Origin", clientOrigin);
         response.setHeader("Access-Control-Allow-Methods", "POST, GET,  DELETE, PUT");
         response.setHeader("Access-Control-Allow-Credentials", "true");
         response.setHeader("Access-Control-Max-Age", "3600");
         response.setHeader("Access-Control-Allow-Headers", "Accept, Content-Type, Origin, Authorization, X-Auth-Token");
		 
		 
		 import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

/**
 *
 * @author Matias
 */
public class JavaApplication5 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

	  try {

		URL url = new URL("http://localhost:8080/login");
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setDoOutput(true);
		conn.setRequestMethod("POST");
		conn.setRequestProperty("Content-Type", "application/json");

		String input = "{\"username\":\"matias\",\"password\":\"12345\"}";

		OutputStream os = conn.getOutputStream();
		os.write(input.getBytes());
		os.flush();

                String token = conn.getHeaderField("Authorization");

                System.out.println(token.trim());

		conn.disconnect();

                url = new URL("http://localhost:8080/v1/socialMedias");
		conn = (HttpURLConnection) url.openConnection();
		conn.setRequestMethod("GET");
                conn.setRequestProperty("Authorization", token);
		conn.setRequestProperty("Accept", "application/json");

		if (conn.getResponseCode() != 200) {
			thrownew RuntimeException("Failed : HTTP error code : "
					+ conn.getResponseCode());
		}

		BufferedReader br = new BufferedReader(new InputStreamReader(
			(conn.getInputStream())));

		String output;
		System.out.println("Output from Server .... \n");
		while ((output = br.readLine()) != null) {
			System.out.println(output);
		}

		conn.disconnect();                

	  } catch (MalformedURLException e) {

		e.printStackTrace();

	  } catch (IOException e) {

		e.printStackTrace();

	 }

    }

}
	
	=============

/**
 * Retrieve access token, if needed, retrieve instance url, and set server host URL
 * {@inheritDoc}
 * @see org.apache.gobblin.writer.http.HttpWriter#onConnect(org.apache.http.HttpHost)
 */
@Override
public void onConnect(URI serverHost) throws IOException {
 if (!StringUtils.isEmpty(accessToken)) {
  return; //No need to be called if accessToken is active.
 }
 try {
  getLog().info("Getting Oauth2 access token.");
  OAuthClientRequest request = OAuthClientRequest.tokenLocation(serverHost.toString())
    .setGrantType(GrantType.PASSWORD)
    .setClientId(clientId)
    .setClientSecret(clientSecret)
    .setUsername(userId)
    .setPassword(password + securityToken).buildQueryMessage();
  OAuthClient client = new OAuthClient(new URLConnectionClient());
  OAuthJSONAccessTokenResponse response = client.accessToken(request, OAuth.HttpMethod.POST);
  accessToken = response.getAccessToken();
  setCurServerHost(new URI(response.getParam("instance_url")));
 } catch (OAuthProblemException e) {
  throw new NonTransientException("Error while authenticating with Oauth2", e);
 } catch (OAuthSystemException e) {
  throw new RuntimeException("Failed getting access token", e);
 } catch (URISyntaxException e) {
  throw new RuntimeException("Failed due to invalid instance url", e);
 }
}
=====

HttpPost post = new HttpPost(
oauthDetails.getAuthenticationServerUrl());
String clientId = oauthDetails.getClientId();
String clientSecret = oauthDetails.getClientSecret();
String scope = oauthDetails.getScope();
 
List<BasicNameValuePair> parametersBody =
new ArrayList<BasicNameValuePair>();
parametersBody.add(new BasicNameValuePair(OAuthConstants.GRANT_TYPE,
oauthDetails.getGrantType()));
parametersBody.add(new BasicNameValuePair(OAuthConstants.Client_ID,
clientId));
parametersBody.add(new BasicNameValuePair(OAuthConstants.Client_Secret,
clientSecret));
 
 
if (isValid(scope)) {
   parametersBody.add(new BasicNameValuePair
     (OAuthConstants.SCOPE,scope));
 }
 
DefaultHttpClient client = new DefaultHttpClient();
HttpResponse response = null;
String accessToken = null;
  try {
   post.setEntity(new UrlEncodedFormEntity(parametersBody,
      HTTP.UTF_8));
    
   response = client.execute(post);
   int code = response.getStatusLine().getStatusCode();
   if (code == 401) {
   System.out.println("Authorization
      server expects Basic authentication");
   // Add Basic Authorization header
   post.addHeader(
   OAuthConstants.AUTHORIZATION,
   getBasicAuthorizationHeader(oauthDetails.clientId,
   clientSecret));
   System.out.println("Retry with client credentials");
   post.releaseConnection();
   response = client.execute(post);
   code = response.getStatusLine().getStatusCode();
    
   if (code == 401) {
   throw new RuntimeException(
   "Could not retrieve access token for client: "
   clientId);
      }
       }
     }
   Map<String, String> map = handleResponse(response);
   accessToken = map.get(OAuthConstants.ACCESS_TOKEN);
   } catch (ClientProtocolException e) {
           // TODO Auto-generated catch block
           e.printStackTrace();
   } catch (IOException e) {
           // TODO Auto-generated catch block
           e.printStackTrace();
   }
 
   return accessToken;
   
   =============
   
   
   String resourceURL = oauthDetails.getResourceServerUrl();
                 
HttpGet get = new HttpGet(resourceURL);
get.addHeader(OAuthConstants.AUTHORIZATION,
 getAuthorizationHeaderForAccessToken(oauthDetails
  .getAccessToken()));
DefaultHttpClient client = new DefaultHttpClient();
HttpResponse response = null;
int code = -1;
    try {
    response = client.execute(get);
    code = response.getStatusLine().getStatusCode();
    if (code == 401) {
     // Access token is invalid or expired. Regenerate the access
     // token
     System.out
     .println("Access token is invalid or expired. Regenerating access    token....");
     String accessToken = getAccessToken(oauthDetails);
     if (isValid(accessToken)) {
      // update the access token
      // System.out.println("New access token: " + accessToken);
       oauthDetails.setAccessToken(accessToken);
       get.removeHeaders(OAuthConstants.AUTHORIZATION);
       get.addHeader(OAuthConstants.AUTHORIZATION,
       getAuthorizationHeaderForAccessToken(oauthDetails
       .getAccessToken()));
       get.releaseConnection();
       response = client.execute(get);
       code = response.getStatusLine().getStatusCode();
        if (code == 401) {
            throw new RuntimeException(
            "Could not access protected resource. Server returned http          code: " + code);
 
        }
 
      }
        else {
         throw new RuntimeException(
         Could not regenerate access token");
           }
 
       }
 
        handleResponse(response);

==================

/**
 * Licensed Materials - Property of IBM Corporation.
 * 
 * 5725-A20
 * 
 * Copyright IBM Corporation 2017. All Rights Reserved.
 * 
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corporation.
 */
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;

import org.apache.wink.json4j.JSONArray;
import org.apache.wink.json4j.JSONException;
import org.apache.wink.json4j.JSONObject;

/**
 * This Java template provides an example of how you might call the Blueworks Live UserList API using a Service ID.
 * You will need a Service ID in the User Management category. Contact your account admin if you do not have one. Ensure
 * they provide you with the JSON file associated with that Service ID.
 * 
 * The example demonstrates how you would:
 *  - Identify the URL of the server to call.
 *  - Request a short-lived OAuth2 token using the client ID and client secret provided with your Service ID.
 *  - Issue an API call using the OAuth2 token.
 *  - Detect token expiration and request a new token.
 * 
 * The template uses the JSON4J library from the Apache Wink project (http://wink.apache.org/) to parse the
 * JSON responses sent back by the API.
 * 
 * 1. Download the JAR from https://mvnrepository.com/artifact/org.apache.wink/wink-json4j/1.4
 * 
 * 2. Compile the sample (The following code assumes you are using the Windows command prompt):
 *    javac -cp .;wink-json4j-1.4.0.jar RestApiServiceIdClientTemplate.java
 * 
 * 3. Run it, changing the client credentials to something valid:
 *    java -cp .;wink-json4j-1.4.0.jar RestApiServiceIdClientTemplate
 * 
 * You can use your favorite JSON library.
 * 
 */
public class RestApiServiceIdClientTemplate {

    /**
     * The Blueworks Live server to access the APIs from.
     * If you're not sure what to set this to, don't worry. The first time you run this example, you'll get a message
     * telling you what URL to specify here.
     */
    private final static String BWL_SERVER = "https://www.blueworkslive.com"; //TODO: replace this with your Blueworks Live server address.

    /**
     * The path to the UserList API.
     */
    private final static String USERLIST_API_PATH = BWL_SERVER + "/scr/api/UserList";

    /**
     * The version of the API you want to use. Different versions of the API require different input parameters and
     * return results in different formats.
     */
    private final static String USERLIST_VERSION = "20110917";

    /**
     * The path to the endpoint where you can request an access token using the client ID and client secret obtained from
     * creating or reactivating your Service ID.
     */
    private final static String TOKEN_ENDPOINT = BWL_SERVER + "/oauth/token";
    
    /**
     * The client ID and client secret for the Service ID accessing the REST APIs. This example hard codes the
     * values for ease of instruction, but in reality, you would use a robust approach that can accommodate change.
     * For example, consider adding code to parse and extract the client ID and client secret from the JSON
     * file you receive when you create or reactivate a Service ID.
     * 
     * In this example, because you are accessing the UserList API, the Service ID that you use must belong
     * to the User Management category.
     */
    private final static String CLIENT_ID = "your client ID"; //TODO: replace this with your client ID. For example: 08b60891-1002-45f5-8e05-9876aee2ed88
    private final static String CLIENT_SECRET = "your client secret"; //TODO: replace this with your client secret. For example: YWRtaW4xNDk2ODQ5NTMyNjM4NWY1MDFlNTE5Y2RmYg==

    public static void main(String[] args) {
        try {
            // Construct the path to the API with the query parameters.
            StringBuilder urlBuilder = new StringBuilder(USERLIST_API_PATH);
            urlBuilder.append("?version=").append(USERLIST_VERSION);
            String pathWithQueryParams = urlBuilder.toString();

            InputStream restApiStream = null;
            HttpURLConnection restApiConnection = getRestApiConnection(pathWithQueryParams);

            // 1. Request an access token.
            String accessToken = requestAccessToken();

            // 2. Invoke the UserList API using the access token.
            addAuthenticationHeader(restApiConnection, accessToken);
            if (restApiConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
                if (restApiConnection.getResponseCode() == HttpURLConnection.HTTP_UNAUTHORIZED) {
                    if (restApiConnection.getHeaderField("www-authenticate").contains("invalid_token")) {
                        // This response might mean that the token expired. Try a new connection with a new access token.
                        String newAccessToken = requestAccessToken();
                        HttpURLConnection restApiConnectionWithNewAccessToken = getRestApiConnection(pathWithQueryParams);
                        addAuthenticationHeader(restApiConnectionWithNewAccessToken, newAccessToken);

                        // Validate the connection established using the new token.
                        if (restApiConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
                            System.err.println("Error calling the Blueworks Live REST API: " + restApiConnection.getResponseMessage());
                            System.exit(1);
                        }
                        restApiStream = restApiConnectionWithNewAccessToken.getInputStream();
                    }
                } else if (restApiConnection.getResponseCode() == HttpURLConnection.HTTP_FORBIDDEN) {
                    // This response might mean that you made a request to the UserList API using the wrong Service ID category and
                    // you should handle this in your code.
                    System.err.println("Insufficient access to the Blueworks Live REST API: " + restApiConnection.getResponseMessage());
                }
                System.err.println("Error calling the Blueworks Live REST API: " + restApiConnection.getResponseMessage());
                System.exit(1);
            } else {
                restApiStream = restApiConnection.getInputStream();    
            }

            // 3. Process the JSON result. This example prints the name of each user.
            try {
                JSONObject userListApiResult = new JSONObject(restApiStream);
                JSONArray users = (JSONArray) userListApiResult.get("users");
                for (Object user : users) {
                    System.out.println("User name=" + ((JSONObject) user).get("name"));
                }
            } finally {
                // Clean up the streams you opened.
                if (restApiStream != null) {
                    restApiStream.close();
                }
            }
        } catch (Exception e) {
            // Handle the exceptions that might occur.
            // Perform exception handling suited to your application, which might include distinguishing 
            // the type of exception and handling it appropriately. For example, you might want to handle
            // authentication problems separately so that the user will know their credentials caused the problem.
            e.printStackTrace();
        }
    }

    /**
     * Set up the connection to a REST API including handling the Bearer Authentication request header that must be
     * present on every API call.
     * 
     * @param apiCall The URL string indicating the API call and parameters.
     * @return the open connection
     */
    private static HttpURLConnection getRestApiConnection(String apiCall) throws IOException {
        URL restApiUrl = new URL(apiCall);
        HttpURLConnection restApiURLConnection = (HttpURLConnection) restApiUrl.openConnection();
        return restApiURLConnection;
    }

    /**
     * Add the HTTP Bearer authentication header that must be present on every API call.
     * 
     * @param restApiURLConnection The open connection to the REST API.
     */
    private static void addAuthenticationHeader(HttpURLConnection restApiURLConnection, String accessToken) {
        restApiURLConnection.setRequestProperty("Authorization", "Bearer " + accessToken);
    }

    /**
     * Request an access token using the client ID and client secret obtained from your Service ID. Because access
     * tokens have an expiry time, it's best to request a token before fulfilling your requests.
     * 
     * @return the access token that you can use to access protected Blueworks Live resources.
     */
    private static String requestAccessToken() throws IOException, JSONException {
        byte[] postData = getRequestBodyForAccessToken();
        int postDataLength = postData.length;

        URL url = new URL(TOKEN_ENDPOINT);
        HttpURLConnection endPointRequestConnection = (HttpURLConnection) url.openConnection();           
        endPointRequestConnection.setRequestMethod("POST");
        endPointRequestConnection.setDoOutput(true);
        endPointRequestConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); 
        endPointRequestConnection.setRequestProperty("Content-Length", Integer.toString(postDataLength));
        endPointRequestConnection.setInstanceFollowRedirects(false);
        try (DataOutputStream dos = new DataOutputStream(endPointRequestConnection.getOutputStream())) {
           dos.write(postData);
        }

        if (endPointRequestConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            if (endPointRequestConnection.getResponseCode() == HttpURLConnection.HTTP_MOVED_PERM) {
                String serverURL = endPointRequestConnection.getHeaderField("Location");
                // TODO Replace the value of the BWL_SERVER constant with this new URL.
                System.err.println("Set the value of the BWL_SERVER constant to: " + serverURL);
            }
            System.err.println("Error in obtaining an access token. " + endPointRequestConnection.getResponseMessage());
            System.exit(1);
        }

        // Process the JSON result to retrieve the access token.
        String accessToken;
        try (InputStream tokenRequestStream = endPointRequestConnection.getInputStream()) {
            JSONObject tokenRequestResult = new JSONObject(tokenRequestStream);
            accessToken = (String) tokenRequestResult.get("access_token");
        }
        return accessToken;
    }

    /**
     * Get the request body to be used for the POST request when requesting an access token.
     */
    private static byte[] getRequestBodyForAccessToken() {
        StringBuilder sb = new StringBuilder("grant_type=client_credentials");
        sb.append("&client_id=")
          .append(CLIENT_ID)
          .append("&client_secret=")
          .append(CLIENT_SECRET);
        return sb.toString().getBytes(StandardCharsets.UTF_8);
    }
}

================

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.ThreadLocalRandom;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Enumeration;
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;


import org.apache.commons.ssl.Base64;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.CookieStore;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPatch;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;


import com.microstrategy.web.objects.WebIServerSession;
import com.microstrategy.web.objects.WebObjectsException;
import com.microstrategy.web.objects.WebObjectsFactory;


public class REST_Create_Locate_UpdateCubeDynamically {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

		//CONFIG PARAMETERS:
		String baseRestURL = "https://env-73627.customer.cloud.microstrategy.com/MicroStrategyLibrary"";
		String cubeName = "MyCube";
		String username = "steve";
		String password = "";
		String projectID = "B7CA92F04B9FAE8D941C3E9B7E0CD754"; 
		String updatePolicy = "add";
		
		//Create HTTPClient
		HttpClient httpClient = null;
		CookieStore httpCookieStore = new BasicCookieStore();
		HttpClientBuilder builder = HttpClientBuilder.create().setDefaultCookieStore(httpCookieStore);
		httpClient = builder.build();
		
		
		//Create Session
		String authToken = createAuthToken(baseRestURL, httpClient, username, password);
		System.out.println("Auth Token: " + authToken);
		
		if(authToken == null){
			System.out.println("Error: Unable to generate authToken");
			return;
		}
		
		//The below sample will generate data that creates an Attribute of ID, and a metric of Price
		
		//Create row(s) of data for cube:
		int id_val = ThreadLocalRandom.current().nextInt(10000, 99999 + 1);
		int price_val = ThreadLocalRandom.current().nextInt(10000, 99999 + 1);
		String JSONString = "[{\"ID\":"+id_val+",\"Price\":"+price_val+"}]";
		String base64EncodedData = encodeJSON(JSONString);
		
		//The table will define 2 columns called ID and Price of type 'double'. We will then map the ID column to an attribute and the price column to a metric in the table structure JSON. 
		
		//define create table structure
		String tableStructureCreate = "{\"name\":\""+cubeName+"\",\"tables\":[{\"data\":\""+base64EncodedData+"\",\"name\":\"Table\",\"columnHeaders\":[{\"name\":\"ID\",\"dataType\":\"DOUBLE\"},{\"name\":\"Price\",\"dataType\":\"DOUBLE\"}]}],\"metrics\":[{\"name\":\"Price\",\"dataType\":\"number\",\"expressions\":[{\"formula\":\"Table.Price\"}]}],\"attributes\":[{\"name\":\"ID\",\"attributeForms\":[{\"category\":\"ID\",\"expressions\":[{\"formula\":\"Table.ID\"}],\"dataType\":\"double\"}]}]}";
		
		//define update table structure 
		String tableStructureUpdate = "{\"name\":\"Table\",\"columnHeaders\":[{\"name\":\"ID\",\"dataType\":\"DOUBLE\"},{\"name\":\"Price\",\"dataType\":\"DOUBLE\"}],\"data\":\""+base64EncodedData+"\"}";
		
		//Create or update cube
		createOrUpdateCube(baseRestURL, authToken, httpClient, projectID, updatePolicy, cubeName, tableStructureCreate, tableStructureUpdate);
	}
	
	//Creates an AuthToken
	public static String createAuthToken(String baseRestURL, HttpClient httpClient, String username, String password){
		String APIPath = "/api/auth/login";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println(completeRestURL);
	    
		// Define the server endpoint to send the HTTP request to
	    URL serverUrl;
		try {
			serverUrl = new URL(completeRestURL);
		
			HttpPost httpRequest = new HttpPost(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			StringEntity body =new StringEntity("{\"username\": \""+username+"\",\"password\": \""+password+"\",\"loginMode\": 1,\"applicationType\": 35}");
			httpRequest.setEntity(body);
			 
			HttpResponse response = httpClient.execute(httpRequest);
			
			Header[] headers = (Header[]) response.getAllHeaders();
			for (int i = 0; i < headers.length; i++){
				Header header = headers[i];
				//System.out.println(header.getName() + " : " + header.getValue());
				if (header.getName().equalsIgnoreCase("X-MSTR-AuthToken")){
					return header.getValue();
				}
			}
			
			return null;
			
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	
	//Performs a metadata search to pull items back from the MyReports folder
	public static String searchPersonalFolderForMyReports(String baseRestURL, String authToken, HttpClient httpClient, String projectID){
		String APIPath = "/api/folders/myPersonalObjects";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println(completeRestURL);
	    
		

		try {
			HttpGet httpRequest = new HttpGet(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			httpRequest.setHeader("X-MSTR-AuthToken", authToken);
			httpRequest.setHeader("X-MSTR-ProjectID", projectID);
		
			HttpResponse response = httpClient.execute(httpRequest);
						
			HttpEntity entity = response.getEntity();
			String responseString = EntityUtils.toString(entity, "UTF-8");
			System.out.println(responseString);
			JSONArray jsonArray = new JSONArray(responseString);
			
		
			//Locate my reports ID
			for (int i = 0; i < jsonArray.length(); i++){		
				JSONObject obj =  (JSONObject) jsonArray.get(i);
				if(obj.get("name").toString().equalsIgnoreCase("My Reports")){
					return obj.getString("id");
				}
				
			}
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return null;
	}
	
	//Returns a list of objects contained in the MyReports folder
	public static String searchMyReportsForCube(String baseRestURL, String authToken, HttpClient httpClient, String projectID,String myReportsID, String cubeName){
		String APIPath = "/api/folders/" + myReportsID;
		String completeRestURL = baseRestURL + APIPath;
		System.out.println(completeRestURL);
	    
		try {
			HttpGet httpRequest = new HttpGet(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			httpRequest.setHeader("X-MSTR-AuthToken", authToken);
			httpRequest.setHeader("X-MSTR-ProjectID", projectID);
		
			HttpResponse response = httpClient.execute(httpRequest);
						
			HttpEntity entity = response.getEntity();
			String responseString = EntityUtils.toString(entity, "UTF-8");
			System.out.println(responseString);
			JSONArray jsonArray = new JSONArray(responseString);
			
		
			//Locate my reports ID
			for (int i = 0; i < jsonArray.length(); i++){		
				JSONObject obj =  (JSONObject) jsonArray.get(i);
				if(obj.get("name").toString().equalsIgnoreCase(cubeName) && obj.getInt("type")==3){
					return obj.getString("id");
				}
				
			}
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return null;
	}
	
	public static String createOrUpdateCube(String baseRestURL, String authToken, HttpClient httpClient, String projectID, String updatePolicy, String cubeName, String tableStructureCreate, String tableStructureUpdate){
		//First action is to see if the cube exists in the metadata within the My Reports folder:
		//Search Personal folder
		String myReportsID = searchPersonalFolderForMyReports(baseRestURL, authToken, httpClient, projectID);
		System.out.println("MyReportsFolder ID: " + myReportsID);
		
		//If the ID is located, next we query for the ID of the cube in this folder:
		//Search for cube in my reports
		String cubeID = searchMyReportsForCube(baseRestURL, authToken, httpClient, projectID, myReportsID, cubeName);
		System.out.println("CubeID: " + cubeID);
		
		//If the cube is null, then the cube should be created:
		if(cubeID == null){
			System.out.println("Unable to locate Cube named " + cubeName);
			
			//Create cube:
			String responseString = createCubeWithInitialData(baseRestURL, authToken, httpClient, projectID, tableStructureCreate);
			return responseString;
		}
		else{
			System.out.println("Cube with name " + cubeName + " exists, append data to cube" );
		
			
			//Update cube:
			updateCubeWithAdditionalData(baseRestURL, authToken, httpClient, projectID, tableStructureUpdate, cubeID, updatePolicy);
		}
	
		return null;
	}
	
	//Performs a POST Request to initially write data to a cube with the variables provided
	public static String createCubeWithInitialData(String baseRestURL, String authToken, HttpClient httpClient, String projectID, String tableStructure){
		String APIPath = "/api/datasets";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println("REST API URL: "  + completeRestURL);
		
		try {
			HttpPost httpRequest = new HttpPost(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			httpRequest.setHeader("X-MSTR-AuthToken", authToken);
			httpRequest.setHeader("X-MSTR-ProjectID", projectID);
			//httpRequest.setHeader("Set-Cookie", JSESSIONID);
			httpRequest.setHeader("updatePolicy", "Add");
			StringEntity body;
		
			body = new StringEntity(tableStructure);
			httpRequest.setEntity(body);
			HttpResponse response = httpClient.execute(httpRequest);
			
			
			HttpEntity entity = response.getEntity();
			String responseString = EntityUtils.toString(entity, "UTF-8");
			System.out.println(responseString);
			
			return responseString;
			
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return null;
	}
	
	
	//Performs a POST Request to update  data to a cube with the variables provided
	public static String updateCubeWithAdditionalData(String baseRestURL, String authToken, HttpClient httpClient, String projectID, String tableStructure, String datasetID, String updatePolicy){
		System.out.println("PatchCubeWithAdditionalData");
		System.out.println("-------");
		System.out.println("TableStructure: " + tableStructure);
		System.out.println("CubeID: " + datasetID);
		System.out.println("UpdatePolicy: " + updatePolicy);
		
	    String APIPath = "/api/datasets/"+datasetID+"/tables/Table";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println(completeRestURL);
		
		System.out.println("-------");
	    
		try {
			HttpPatch httpRequest = new HttpPatch(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			httpRequest.setHeader("X-MSTR-AuthToken", authToken);
			httpRequest.setHeader("updatePolicy", updatePolicy);
			
			httpRequest.setHeader("X-MSTR-ProjectID", projectID);
			StringEntity body;
		
			body = new StringEntity(tableStructure);
			httpRequest.setEntity(body);
			HttpResponse response = httpClient.execute(httpRequest);
			
			
			HttpEntity entity = response.getEntity();
			String responseString = EntityUtils.toString(entity, "UTF-8");
			System.out.println("STATUS: " + response.getStatusLine().getStatusCode());
			System.out.println("PATCH RESPONSE: " + responseString);
			
			
			return responseString;
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	
	public static String encodeJSON(String JSONString){
		
		// encode data on your side using BASE64
		byte[]   bytesEncoded = Base64.encodeBase64(JSONString.getBytes());
		//System.out.println("ecncoded value is " + new String(bytesEncoded ));
		String encoded = new String(bytesEncoded); //base64

		return encoded;
	}
	
}
========

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.ThreadLocalRandom;

import org.apache.commons.ssl.Base64;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.CookieStore;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPatch;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;

public class REST_UpdateCubeWithAdditionalData {
	public static void main(String[] args) {
		//CONFIG PARAMETERS:
		//BEGIN------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		String baseRestURL = "https://env-73627.customer.cloud.microstrategy.com/MicroStrategyLibrary""; //Path to API
		String cubeName = "MyCube"; //Name of cube to create
		String username = "steve"; 
		String password = "";
		String projectID = "B7CA92F04B9FAE8D941C3E9B7E0CD754";  //Project ID
		String updatePolicy = "add";
		String existingCubeID = "2E61029611E7BC19AD7D0080EFC5FD9D"; //ID of cube to update (cube must have been created with REST API)
		//END------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		
		//Create HTTPClient - Used to make Request to API
		HttpClient httpClient = null;
		CookieStore httpCookieStore = new BasicCookieStore();
		HttpClientBuilder builder = HttpClientBuilder.create().setDefaultCookieStore(httpCookieStore);
		httpClient = builder.build();
		
		//Create Session using /api/auth/login
		String authToken = createAuthToken(baseRestURL, httpClient, username, password);
		System.out.println("Auth Token: " + authToken);
		
		if(authToken == null){
			System.out.println("Error: Unable to generate authToken - check to see if server is running");
			return;
		}
		
		//The below sample will generate data that creates an Attribute of ID, and a metric of Price
		
		//Create row(s) of data for cube:
		int id_val = ThreadLocalRandom.current().nextInt(10000, 99999 + 1);
		int price_val = ThreadLocalRandom.current().nextInt(10000, 99999 + 1);
		String JSONString = "[{\"ID\":"+id_val+",\"Price\":"+price_val+"}]";
		String base64EncodedData = encodeJSON(JSONString);
		
		//The table will define 2 columns called ID and Price of type 'double'. We will then map the ID column to an attribute and the price column to a metric in the table structure JSON. 
		
		//define table structure
		String tableStructure = "{\"name\":\"Table\",\"columnHeaders\":[{\"name\":\"ID\",\"dataType\":\"DOUBLE\"},{\"name\":\"Price\",\"dataType\":\"DOUBLE\"}],\"data\":\""+base64EncodedData+"\"}";
		//Create or update cube
		updateCubeWithAdditionalData(baseRestURL, authToken, httpClient, projectID, tableStructure, existingCubeID, updatePolicy);
	}
		
	//Creates an AuthToken
	public static String createAuthToken(String baseRestURL, HttpClient httpClient, String username, String password){
		String APIPath = "/api/auth/login";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println("REST API URL: " + completeRestURL);
	    
		// Define the server endpoint to send the HTTP request to
	    URL serverUrl;
		try {
			serverUrl = new URL(completeRestURL);
		
			HttpPost httpRequest = new HttpPost(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			StringEntity body =new StringEntity("{\"username\": \""+username+"\",\"password\": \""+password+"\",\"loginMode\": 1,\"applicationType\": 35}");
			httpRequest.setEntity(body);
			 
			HttpResponse response = httpClient.execute(httpRequest);
			
			Header[] headers = (Header[]) response.getAllHeaders();
			for (int i = 0; i < headers.length; i++){
				Header header = headers[i];
				//System.out.println(header.getName() + " : " + header.getValue());
				if (header.getName().equalsIgnoreCase("X-MSTR-AuthToken")){
					return header.getValue();
				}
			}
			
			return null;
			
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}


	

	//Performs a POST Request to update  data to a cube with the variables provided
	public static String updateCubeWithAdditionalData(String baseRestURL, String authToken, HttpClient httpClient, String projectID, String tableStructure, String datasetID, String updatePolicy){
		System.out.println("PatchCubeWithAdditionalData");
		System.out.println("-------");
		System.out.println("TableStructure: " + tableStructure);
		System.out.println("CubeID: " + datasetID);
		System.out.println("UpdatePolicy: " + updatePolicy);
		
	    String APIPath = "/api/datasets/"+datasetID+"/tables/Table";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println(completeRestURL);
		
		System.out.println("-------");
	    
		try {
			HttpPatch httpRequest = new HttpPatch(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			httpRequest.setHeader("X-MSTR-AuthToken", authToken);
			httpRequest.setHeader("updatePolicy", updatePolicy);
			
			httpRequest.setHeader("X-MSTR-ProjectID", projectID);
			StringEntity body;
		
			body = new StringEntity(tableStructure);
			httpRequest.setEntity(body);
			HttpResponse response = httpClient.execute(httpRequest);
			
			
			HttpEntity entity = response.getEntity();
			String responseString = EntityUtils.toString(entity, "UTF-8");
			System.out.println("STATUS: " + response.getStatusLine().getStatusCode());
			System.out.println("PATCH RESPONSE: " + responseString);
			
			
			return responseString;
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	public static String encodeJSON(String JSONString){
		
		// encode data on your side using BASE64
		byte[]   bytesEncoded = Base64.encodeBase64(JSONString.getBytes());
		//System.out.println("ecncoded value is " + new String(bytesEncoded ));
		String encoded = new String(bytesEncoded); //base64

		return encoded;
	}
	

}

============

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.ThreadLocalRandom;

import org.apache.commons.ssl.Base64;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.CookieStore;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;

public class REST_CreateCubeWithInitialData {
	public static void main(String[] args) {
		//CONFIG PARAMETERS:
		//BEGIN------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		String baseRestURL = "https://env-73627.customer.cloud.microstrategy.com/MicroStrategyLibrary"";
		String cubeName = "MyCube";
		String username = "steve"; 
		String password = "";
		String projectID = "B7CA92F04B9FAE8D941C3E9B7E0CD754"; 
		String updatePolicy = "add";
		//END------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		
		//Create HTTPClient - Used to make Request to API
		HttpClient httpClient = null;
		CookieStore httpCookieStore = new BasicCookieStore();
		HttpClientBuilder builder = HttpClientBuilder.create().setDefaultCookieStore(httpCookieStore);
		httpClient = builder.build();
		
		//Create Session using /api/auth/login
		String authToken = createAuthToken(baseRestURL, httpClient, username, password);
		System.out.println("Auth Token: " + authToken);
		
		if(authToken == null){
			System.out.println("Error: Unable to generate authToken - check to see if server is running");
			return;
		}
		
		//The below sample will generate data that creates an Attribute of ID, and a metric of Price
		
		//Create row(s) of data for cube:
		int id_val = ThreadLocalRandom.current().nextInt(10000, 99999 + 1);
		int price_val = ThreadLocalRandom.current().nextInt(10000, 99999 + 1);
		String JSONString = "[{\"ID\":"+id_val+",\"Price\":"+price_val+"}]";
		String base64EncodedData = encodeJSON(JSONString);
		
		//The table will define 2 columns called ID and Price of type 'double'. We will then map the ID column to an attribute and the price column to a metric in the table structure JSON. 
		
		//define table structure
		String tableStructure = "{\"name\":\""+cubeName+"\",\"tables\":[{\"data\":\""+base64EncodedData+"\",\"name\":\"Table\",\"columnHeaders\":[{\"name\":\"ID\",\"dataType\":\"DOUBLE\"},{\"name\":\"Price\",\"dataType\":\"DOUBLE\"}]}],\"metrics\":[{\"name\":\"Price\",\"dataType\":\"number\",\"expressions\":[{\"formula\":\"Table.Price\"}]}],\"attributes\":[{\"name\":\"ID\",\"attributeForms\":[{\"category\":\"ID\",\"expressions\":[{\"formula\":\"Table.ID\"}],\"dataType\":\"double\"}]}]}";
		//Create or update cube
		createCubeWithInitialData(baseRestURL, authToken, httpClient, projectID, tableStructure);
	}
		
	//Creates an AuthToken
	public static String createAuthToken(String baseRestURL, HttpClient httpClient, String username, String password){
		String APIPath = "/api/auth/login";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println("REST API URL: " + completeRestURL);
	    
		// Define the server endpoint to send the HTTP request to
	    URL serverUrl;
		try {
			serverUrl = new URL(completeRestURL);
		
			HttpPost httpRequest = new HttpPost(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			StringEntity body =new StringEntity("{\"username\": \""+username+"\",\"password\": \""+password+"\",\"loginMode\": 1,\"applicationType\": 35}");
			httpRequest.setEntity(body);
			 
			HttpResponse response = httpClient.execute(httpRequest);
			
			Header[] headers = (Header[]) response.getAllHeaders();
			for (int i = 0; i < headers.length; i++){
				Header header = headers[i];
				//System.out.println(header.getName() + " : " + header.getValue());
				if (header.getName().equalsIgnoreCase("X-MSTR-AuthToken")){
					return header.getValue();
				}
			}
			
			return null;
			
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}


	
	//Performs a POST Request to initially write data to a cube with the variables provided
	public static String createCubeWithInitialData(String baseRestURL, String authToken, HttpClient httpClient, String projectID, String tableStructure){
		String APIPath = "/api/datasets";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println("REST API URL: "  + completeRestURL);
		
		try {
			HttpPost httpRequest = new HttpPost(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			httpRequest.setHeader("X-MSTR-AuthToken", authToken);
			httpRequest.setHeader("X-MSTR-ProjectID", projectID);
			//httpRequest.setHeader("Set-Cookie", JSESSIONID);
			httpRequest.setHeader("updatePolicy", "Add");
			StringEntity body;
		
			body = new StringEntity(tableStructure);
			httpRequest.setEntity(body);
			HttpResponse response = httpClient.execute(httpRequest);
			
			
			HttpEntity entity = response.getEntity();
			String responseString = EntityUtils.toString(entity, "UTF-8");
			System.out.println(responseString);
			
			return responseString;
			
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return null;
	}
	
	
	public static String encodeJSON(String JSONString){
		
		// encode data on your side using BASE64
		byte[]   bytesEncoded = Base64.encodeBase64(JSONString.getBytes());
		//System.out.println("ecncoded value is " + new String(bytesEncoded ));
		String encoded = new String(bytesEncoded); //base64

		return encoded;
	}
	

}

========

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import org.apache.http.Header;
import org.apache.http.HttpResponse;
import org.apache.http.client.CookieStore;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.impl.client.HttpClientBuilder;

public class REST_CreateSession {
	public static void main(String[] args) {
		//CONFIG PARAMETERS:
		//BEGIN------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		String baseRestURL = "https://env-73627.customer.cloud.microstrategy.com/MicroStrategyLibrary"";
		String cubeName = "MyCube";
		String username = "steve"; 
		String password = "";
		String projectID = "B7CA92F04B9FAE8D941C3E9B7E0CD754"; 
		String updatePolicy = "add";
		//END------------CONFIG PARAMETERS BELOW TO YOUR ENVIRONMENT---------------------------------------
		
		//Create HTTPClient - Used to make Request to API
		HttpClient httpClient = null;
		CookieStore httpCookieStore = new BasicCookieStore();
		HttpClientBuilder builder = HttpClientBuilder.create().setDefaultCookieStore(httpCookieStore);
		httpClient = builder.build();
		
		//Create Session using /api/auth/login
		String authToken = createAuthToken(baseRestURL, httpClient, username, password);
		System.out.println("Auth Token: " + authToken);
		
		if(authToken == null){
			System.out.println("Error: Unable to generate authToken - check to see if server is running");
			return;
		}
	}
		
	//Creates an AuthToken
	public static String createAuthToken(String baseRestURL, HttpClient httpClient, String username, String password){
		String APIPath = "/api/auth/login";
		String completeRestURL = baseRestURL + APIPath;
		System.out.println("REST API URL: " + completeRestURL);
	    
		// Define the server endpoint to send the HTTP request to
	    URL serverUrl;
		try {
			serverUrl = new URL(completeRestURL);
		
			HttpPost httpRequest = new HttpPost(completeRestURL);
			httpRequest.setHeader("Content-Type", "application/json");
			httpRequest.setHeader("Accept", "application/json");
			StringEntity body =new StringEntity("{\"username\": \""+username+"\",\"password\": \""+password+"\",\"loginMode\": 1,\"applicationType\": 35}");
			httpRequest.setEntity(body);
			 
			HttpResponse response = httpClient.execute(httpRequest);
			
			Header[] headers = (Header[]) response.getAllHeaders();
			for (int i = 0; i < headers.length; i++){
				Header header = headers[i];
				//System.out.println(header.getName() + " : " + header.getValue());
				if (header.getName().equalsIgnoreCase("X-MSTR-AuthToken")){
					return header.getValue();
				}
			}
			
			return null;
			
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}


}

============

public REST() throws ClientProtocolException, IOException {
        HttpClient httpclient = new DefaultHttpClient();
        HttpPost post = new HttpPost(tokenURL);
        List<NameValuePair> params = new ArrayList<NameValuePair>();
        params.add(new BasicNameValuePair("client_id", "3MVG9rFJvQRVOvk6sl7xMXtrbyQb2XUv2vprLKWv0uxBLKFzNqtHJG6cmzuemPYDB3hPwqXsBlw0BGQPkb81P"));
        params.add(new BasicNameValuePair("client_secret", "4864720658246552438"));
        params.add(new BasicNameValuePair("grant_type", "password"));
        params.add(new BasicNameValuePair("username", "XXXX"));
        params.add(new BasicNameValuePair("password", "XXXX"));
        post.setEntity(new UrlEncodedFormEntity(params));
        HttpResponse response = httpclient.execute(post);
        String body = EntityUtils.toString(response.getEntity());
        System.out.println(body);
    }
	
	
	import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

 

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.DefaultHttpClient;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

 

import com.google.gson.Gson;

 

public class REST
{
String authURL = "https://login.salesforce.com/services/oauth2/authorize";
String tokenURL = "https://na14.salesforce.com/services/oauth2/token";
public static void main(String[] args) throws ClientProtocolException, IOException
{
REST rest = new REST();
}

public REST() throws ClientProtocolException, IOException
{
HttpClient httpclient = new DefaultHttpClient();
HttpPost post = new HttpPost(tokenURL);
post.getParams().setParameter("client_id", "3MVG9rFJvQRVOvk6sl7xMXtrbyQb2XUv2vprLKWv0uxBLKFzNqtHJG6cmzuemPYDB3hPwqXsBlw0BGQPkb81P");
post.getParams().setParameter("client_secret", "4864720658246552438");
post.getParams().setParameter("grant_type", "password");
post.getParams().setParameter("username", "XXXX");
post.getParams().setParameter("password", "XXXX");
post.getParams().setParameter("redirect_uri", "https://login.salesforce.com/services/oauth2/success");
HttpResponse response = httpclient.execute(post);
JSONObject json = (JSONObject) JSONValue.parse(new InputStreamReader (response.getEntity().getContent()));
System.out.println(json);
}
}

======
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;

public void getHttpCon() throws Exception{

    String POST_PARAMS = "grant_type=password&username=someusrname&password=somepswd&scope=profile";
    URL obj = new URL("http://someIP/oauth/token");
    HttpURLConnection con = (HttpURLConnection) obj.openConnection();
    con.setRequestMethod("POST");
            con.setRequestProperty("Content-Type", "application/json;odata=verbose");
    con.setRequestProperty("Authorization",
            "Basic Base64_encoded_clientId:clientSecret");
    con.setRequestProperty("Accept",
            "application/x-www-form-urlencoded");

    // For POST only - START
    con.setDoOutput(true);
    OutputStream os = con.getOutputStream();
    os.write(POST_PARAMS.getBytes());
    os.flush();
    os.close();
    // For POST only - END

    int responseCode = con.getResponseCode();
    System.out.println("POST Response Code :: " + responseCode);

    if (responseCode == HttpURLConnection.HTTP_OK) { //success
        BufferedReader in = new BufferedReader(new InputStreamReader(
                con.getInputStream()));
        String inputLine;
        StringBuffer response = new StringBuffer();

        while ((inputLine = in.readLine()) != null) {
            response.append(inputLine);
        }
        in.close();

        // print result
        System.out.println(response.toString());
    } else {
        System.out.println("POST request not worked");
    }
} 

=========
try {
  TokenResponse response =
      new AuthorizationCodeTokenRequest(new NetHttpTransport(), new JacksonFactory(),
          new GenericUrl("here is the server url "), "here write your code")
          .setRedirectUri("here write the redirectUrl")
          .set("client_id","here write your client_id")
          .set("client_secret","here write your client_secret")
          .set("Other else need","Other else need")
          .execute();
  System.out.println("Access token: " + response.getAccessToken());
} catch (TokenResponseException e) {
  if (e.getDetails() != null) {
    System.err.println("Error: " + e.getDetails().getError());
    if (e.getDetails().getErrorDescription() != null) {
      System.err.println(e.getDetails().getErrorDescription());
    }
    if (e.getDetails().getErrorUri() != null) {
      System.err.println(e.getDetails().getErrorUri());
    }
  } else {
    System.err.println(e.getMessage());
  }
}

===========
OAuthTest.java:

import java.io.*;
import java.net.*;
import org.apache.amber.oauth2.client.*;
import org.apache.amber.oauth2.common.exception.*;
import org.apache.amber.oauth2.common.message.types.*;
import org.apache.amber.oauth2.client.request.*;
import org.apache.amber.oauth2.client.response.*;

public class OAuthTest
{
  // Fabasoft Folio base URL (e.g. http://localhost/fsc)
  private static final String BASEURI = "https://<hostname>/fsc";
  // Client ID as defined by FSCOWS@1.1001:OAuthClient instance
  private static final String CLIENTID = "<client-id>";
  // Client secret as defined by FSCOWS@1.1001:OAuthClient instance
  private static final String CLIENTSECRET = "<client-secret>";
  // Arbitrary redirect URI required for the protocol
  private static final String REDIRECTURI = "http://localhost/";
  // Full reference of an FSCOWS@1.1001:WebServiceDefinition instance
  // containing the action FSCASP@1.1001:ReadContentFriendlyURL
  private static final String SCOPE = "<wsdef-full-reference>";
  // Object address of a NOTE@1.1:NoteObject instance
  private static final String TESTOBJECT = "<noteobject-address>";

  public static void main(String[] args) throws IOException, OAuthSystemException
  {
    try {

      //
      // Build authorization code request
      //
      OAuthClientRequest request = OAuthClientRequest
        .authorizationLocation(BASEURI + "/oauth2/authorize")
        .setClientId(CLIENTID)
        .setScope(SCOPE)
        .setRedirectURI(REDIRECTURI)
        .setResponseType("code")
        .buildQueryMessage();

      System.out.println("Confirm access via the following URL:");
      System.out.println();
      System.out.println(request.getLocationUri());
      System.out.println();
      System.out.print("Enter 'code' query argument value: ");
      BufferedReader reader =
        new BufferedReader(new InputStreamReader(System.in));
      String code = reader.readLine();

      //
      // Build and send token request
      //
      request = OAuthClientRequest
        .tokenLocation(BASEURI + "/oauth2/token")
        .setGrantType(GrantType.AUTHORIZATION_CODE)
        .setClientId(CLIENTID)
        .setClientSecret(CLIENTSECRET)
        .setRedirectURI(REDIRECTURI)
        .setCode(code)
        .buildBodyMessage();

      OAuthClient client = new OAuthClient(new URLConnectionClient());
      OAuthAccessTokenResponse response = client.accessToken(request);
      String accesstoken = response.getAccessToken();
      System.out.println("Token:      " + accesstoken);
      System.out.println("Expiration: " + response.getExpiresIn() + " seconds");

      //
      // Access resource
      //
      URL url = new URL(BASEURI + "/read/" + TESTOBJECT);
      URLConnection conn = url.openConnection();
      conn.setRequestProperty("Authorization", "Bearer " + accesstoken);
      System.out.println("Data:");
      System.out.println();
      reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
      String line = reader.readLine();
      while (line != null) {
        System.out.println(line);
        line = reader.readLine();
      }
    }
    catch (OAuthProblemException e)
    {
      System.out.println("OAuth error:             " + e.getError());
      System.out.println("OAuth error description: " + e.getDescription());
    }
  }
}

====

OAuthClientRequest request = OAuthClientRequest
.tokenLocation(Common.ACCESS_TOKEN_ENDPOINT)
.setGrantType(GrantType.AUTHORIZATION_CODE)
.setCode(Common.AUTHORIZATION_CODE)
.setRedirectURI(Common.REDIRECT_URL)
.setClientId(Common.CLIENT_ID)
.setClientSecret(Common.CLIENT_SECRET)
.buildBodyMessage();
=================

package cn.zetark.oauth2.client;

import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthAccessTokenResponse;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;
import org.apache.oltu.oauth2.common.message.types.ResponseType;
import org.jboss.resteasy.client.jaxrs.ResteasyClient;
import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Form;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;

public class OauthClient {

    /**
     * 获取授权码
     * @return
     * @throws OAuthSystemException
     * @throws MalformedURLException
     * @throws URISyntaxException
     */
	private static Response makeAuthCodeRequest() throws OAuthSystemException,
			MalformedURLException, URISyntaxException {

//		OAuthClientRequest request = OAuthClientRequest
//				.authorizationLocation(ClientParams.OAUTH_SERVER_URL) // oauth2 认证授权地址
//				.setClientId(ClientParams.CLIENT_ID) // CLIENT_ID
//				.setRedirectURI(ClientParams.OAUTH_SERVER_REDIRECT_URI) // 回调地址
//				.setResponseType(ResponseType.CODE.toString()) // 返回类型值
//				.buildQueryMessage();



        // 创建表单，模拟填充表单并提交表单
        Form form = new Form();
        form.param("username",ClientParams.USERNAME);
        form.param("password",ClientParams.PASSWORD);
        form.param("client_id",ClientParams.CLIENT_ID);
        form.param("response_type",ResponseType.CODE.toString());
        form.param("redirect_uri",ClientParams.OAUTH_SERVER_REDIRECT_URI);

        ResteasyClient client = new ResteasyClientBuilder().build();
        Response response = client.target(ClientParams.OAUTH_SERVER_URL)
                .request()
                .post(Entity.form(form));
		System.out.println(response.getStatus());

        String location = response.getLocation().toURL().toString();

        System.out.println(response.getLocation());

        String authCode = location.substring(location.lastIndexOf("=")+1);

        try {
            System.out.println(authCode);
            makeTokenRequestWithAuthCode(authCode);
        } catch (OAuthProblemException e) {
            e.printStackTrace();
        } finally {

        }

        return response;
	}

    /**
     * 根据授权码获取accessToken
     * @param authCode
     * @return
     * @throws OAuthProblemException
     * @throws OAuthSystemException
     */
	private static OAuthAccessTokenResponse makeTokenRequestWithAuthCode(String authCode) throws OAuthProblemException, OAuthSystemException {

        OAuthClientRequest request = OAuthClientRequest
                .tokenLocation(ClientParams.OAUTH_SERVER_TOKEN_URL)
                .setClientId(ClientParams.CLIENT_ID)
                .setClientSecret(ClientParams.CLIENT_SECRET)
                .setGrantType(GrantType.AUTHORIZATION_CODE)
                .setCode(authCode)
                .setRedirectURI(ClientParams.OAUTH_SERVER_REDIRECT_URI)
                .buildBodyMessage();

        OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());

        OAuthAccessTokenResponse oauthResponse = oAuthClient.accessToken(request);

        System.out.println("Access Token: " + oauthResponse.getAccessToken());
        System.out.println("Expires In: " + oauthResponse.getExpiresIn());

        getAuthedService(oauthResponse.getAccessToken());

        return oauthResponse;
    }

    /**
     * 测试开放接口服务
     */
    private static void getAuthedService(String accessToken){
        ResteasyClient client = new ResteasyClientBuilder().build();
        Response response = client.target(ClientParams.OAUTH_SERVICE_API)
                .queryParam("access_token",accessToken)
                .request()
                .get();
        System.out.println(response.getStatus());
        System.out.println(response.readEntity(String.class));
    }

    public static void main(String[] args) throws Exception {

        makeAuthCodeRequest();

    }


}

======
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.getstarted.auth;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.auth.oauth2.TokenResponse;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.http.GenericUrl;
import com.google.api.client.http.HttpRequest;
import com.google.api.client.http.HttpRequestFactory;
import com.google.api.client.http.HttpTransport;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson.JacksonFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

// [START example]
@WebServlet(name = "oauth2callback", value = "/oauth2callback")
@SuppressWarnings("serial")
public class Oauth2CallbackServlet extends HttpServlet {

  private static final Collection<String> SCOPES = Arrays.asList("email", "profile");
  private static final String USERINFO_ENDPOINT
      = "https://www.googleapis.com/plus/v1/people/me/openIdConnect";
  private static final JsonFactory JSON_FACTORY = new JacksonFactory();
  private static final HttpTransport HTTP_TRANSPORT = new NetHttpTransport();

  private GoogleAuthorizationCodeFlow flow;

  @Override
  public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException,
      ServletException {

    // Ensure that this is no request forgery going on, and that the user
    // sending us this connect request is the user that was supposed to.
    if (req.getSession().getAttribute("state") == null
        || !req.getParameter("state").equals((String) req.getSession().getAttribute("state"))) {
      resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
      resp.sendRedirect("/books");
      return;
    }

    req.getSession().removeAttribute("state");     // Remove one-time use state.

    flow = new GoogleAuthorizationCodeFlow.Builder(
        HTTP_TRANSPORT,
        JSON_FACTORY,
        getServletContext().getInitParameter("bookshelf.clientID"),
        getServletContext().getInitParameter("bookshelf.clientSecret"),
        SCOPES).build();

    final TokenResponse tokenResponse =
        flow.newTokenRequest(req.getParameter("code"))
            .setRedirectUri(getServletContext().getInitParameter("bookshelf.callback"))
            .execute();

    req.getSession().setAttribute("token", tokenResponse.toString()); // Keep track of the token.
    final Credential credential = flow.createAndStoreCredential(tokenResponse, null);
    final HttpRequestFactory requestFactory = HTTP_TRANSPORT.createRequestFactory(credential);

    final GenericUrl url = new GenericUrl(USERINFO_ENDPOINT);      // Make an authenticated request.
    final HttpRequest request = requestFactory.buildGetRequest(url);
    request.getHeaders().setContentType("application/json");

    final String jsonIdentity = request.execute().parseAsString();
    @SuppressWarnings("unchecked")
    HashMap<String, String> userIdResult =
        new ObjectMapper().readValue(jsonIdentity, HashMap.class);
    // From this map, extract the relevant profile info and store it in the session.
    req.getSession().setAttribute("userEmail", userIdResult.get("email"));
    req.getSession().setAttribute("userId", userIdResult.get("sub"));
    req.getSession().setAttribute("userImageUrl", userIdResult.get("picture"));
    resp.sendRedirect((String) req.getSession().getAttribute("loginDestination"));
  }
}
// [END example]
==========
  <dependency>
      <groupId>org.apache.shiro</groupId>
      <artifactId>shiro-core</artifactId>
      <version>1.2.4</version>
    </dependency>
		<dependency>
			<groupId>org.apache.oltu.oauth2</groupId>
			<artifactId>org.apache.oltu.oauth2.httpclient4</artifactId>
			<version>1.0.1</version>
			<exclusions>
				<exclusion>
					<groupId>org.apache.oltu.oauth2</groupId>
					<artifactId>org.apache.oltu.oauth2.client</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
    <dependency>
      <groupId>org.apache.oltu.oauth2</groupId>
      <artifactId>org.apache.oltu.oauth2.common</artifactId>
      <version>1.0.1</version>
    </dependency>
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
			<version>4.5.2</version>
		</dependency>
		<dependency>
    <groupId>org.apache.oltu.oauth2</groupId>
    <artifactId>org.apache.oltu.oauth2.client</artifactId>
    <version>1.0</version>
</dependency>
<dependency>
    <groupId>org.apache.oltu.oauth2</groupId>
    <artifactId>org.apache.oltu.oauth2.client</artifactId>
    <version>1.0</version>
</dependency>
==================
OAuthClientRequest request = OAuthClientRequest
                .tokenProvider(OAuthProviderType.FACEBOOK)
                .setGrantType(GrantType.AUTHORIZATION_CODE)
                .setClientId("your-facebook-application-client-id")
                .setClientSecret("your-facebook-application-client-secret")
                .setRedirectURI("http://www.example.com/redirect")
                .setCode(code)
                .buildQueryMessage();
 
            //create OAuth client that uses custom http client under the hood
            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
 
            //Facebook is not fully compatible with OAuth 2.0 draft 10, access token response is
            //application/x-www-form-urlencoded, not json encoded so we use dedicated response class for that
            //Custom response classes are an easy way to deal with oauth providers that introduce modifications to
            //OAuth 2.0 specification
            GitHubTokenResponse oAuthResponse = oAuthClient.accessToken(request, GitHubTokenResponse.class);
 
            String accessToken = oAuthResponse.getAccessToken();
            String expiresIn = oAuthResponse.getExpiresIn();
			
			----------------------------------------------------------------------------------------------
			OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest("https://graph.facebook.com/me")
         .setAccessToken(accessToken).buildQueryMessage();
 
OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);

OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest("https://graph.facebook.com/{album-id}/photos")
         .setAccessToken(accessToken)
         .buildQueryMessage();
 
bearerClientRequest.setHeader(OAuth.HeaderType.CONTENT_TYPE, "multipart/form-data");
bearerClientRequest.setBody(photo);
 
OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.POST, OAuthResourceResponse.class);






<dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.security.oauth.boot</groupId>
        <artifactId>spring-security-oauth2-autoconfigure</artifactId>
        <version>2.1.0.RELEASE</version>
    </dependency>
	
	<!-- https://mvnrepository.com/artifact/com.squareup.retrofit2/retrofit -->
<dependency>
    <groupId>com.squareup.retrofit2</groupId>
    <artifactId>retrofit</artifactId>
    <version>2.6.2</version>
</dependency>

import sun.misc.BASE64Encoder;
 
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
 
public class JersyGetClient {
 
    public static void main(String a[]){
         
        String url = "http://localhost:8080/RestfulWebServices/order-inventory/order/1016";
        String name = "java2novice";
        String password = "Simple4u!";
        String authString = name + ":" + password;
        String authStringEnc = new BASE64Encoder().encode(authString.getBytes());
        System.out.println("Base64 encoded auth string: " + authStringEnc);
        Client restClient = Client.create();
        WebResource webResource = restClient.resource(url);
        ClientResponse resp = webResource.accept("application/json")
                                         .header("Authorization", "Basic " + authStringEnc)
                                         .get(ClientResponse.class);
        if(resp.getStatus() != 200){
            System.err.println("Unable to connect to the server");
        }
        String output = resp.getEntity(String.class);
        System.out.println("response: "+output);
    }
}
========================================================================================================================================
import static com.jayway.restassured.RestAssured.certificate;
import static com.jayway.restassured.RestAssured.given;
import static org.junit.Assert.*;
import static org.hamcrest.Matchers.is;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;
import org.junit.Before;

import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JSR310Module;
import com.jayway.restassured.RestAssured;
import com.jayway.restassured.config.ObjectMapperConfig;
import com.jayway.restassured.config.RestAssuredConfig;
import com.jayway.restassured.mapper.factory.Jackson2ObjectMapperFactory;
import com.jayway.restassured.response.Response;

import fi.otavanopisto.pyramus.AbstractIntegrationTest;
import fi.otavanopisto.pyramus.Common;
import fi.otavanopisto.pyramus.domainmodel.users.Role;
import fi.otavanopisto.pyramus.security.impl.PyramusPermissionCollection;

public abstract class AbstractRESTPermissionsTest extends AbstractIntegrationTest {

	@Before
	public  void setupRestAssured() {

		RestAssured.baseURI = getAppUrl(true) + "/1";
		RestAssured.port = getPortHttps();
		RestAssured.authentication = certificate(getKeystoreFile(), getKeystorePass());

		RestAssured.config = RestAssuredConfig.config().objectMapperConfig(
				ObjectMapperConfig.objectMapperConfig().jackson2ObjectMapperFactory(new Jackson2ObjectMapperFactory() {

					@SuppressWarnings("rawtypes")
					@Override
					public  com.fasterxml.jackson.databind.ObjectMapper create(Class cls, String charset) {
						com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
						objectMapper.registerModule(new JSR310Module());
						objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
						return objectMapper;
					}
				}));

	}

	@Before
	public  void createAccessTokens() {

		OAuthClientRequest tokenRequest = null;

		if (!Role.EVERYONE.name().equals(role)) {
			try {
				tokenRequest = OAuthClientRequest.tokenLocation("https://dev.pyramus.fi:8443/1/oauth/token")
						.setGrantType(GrantType.AUTHORIZATION_CODE)
						.setClientId(fi.otavanopisto.pyramus.Common.CLIENT_ID)
						.setClientSecret(fi.otavanopisto.pyramus.Common.CLIENT_SECRET)
						.setRedirectURI(fi.otavanopisto.pyramus.Common.REDIRECT_URL)
						.setCode(fi.otavanopisto.pyramus.Common.getRoleAuth(Common.strToRole(role))).buildBodyMessage();
			} catch (OAuthSystemException e) {
				e.printStackTrace();
			}
			Response response = given().contentType("application/x-www-form-urlencoded").body(tokenRequest.getBody())
					.post("/oauth/token");
			String accessToken = response.body().jsonPath().getString("access_token");
			setAccessToken(accessToken);
		} else {
			setAccessToken("");
		}

		/**
		 * AdminAccessToken
		 */
		if (!Role.ADMINISTRATOR.name().equals(role)) {
			tokenRequest = null;
			try {
				tokenRequest = OAuthClientRequest.tokenLocation("https://dev.pyramus.fi:8443/1/oauth/token")
						.setGrantType(GrantType.AUTHORIZATION_CODE)
						.setClientId(fi.otavanopisto.pyramus.Common.CLIENT_ID)
						.setClientSecret(fi.otavanopisto.pyramus.Common.CLIENT_SECRET)
						.setRedirectURI(fi.otavanopisto.pyramus.Common.REDIRECT_URL)
						.setCode(fi.otavanopisto.pyramus.Common.getRoleAuth(Role.ADMINISTRATOR)).buildBodyMessage();
			} catch (OAuthSystemException e) {
				e.printStackTrace();
			}
			Response response = given().contentType("application/x-www-form-urlencoded").body(tokenRequest.getBody())
					.post("/oauth/token");

			String adminAccessToken = response.body().jsonPath().getString("access_token");
			setAdminAccessToken(adminAccessToken);
		} else {
			setAdminAccessToken(accessToken);
		}
	}

	public  String getAccessToken() {
		return accessToken;
	}

	public  void setAccessToken(String accessToken) {
		this.accessToken = accessToken;
	}

	public  String getAdminAccessToken() {
		return adminAccessToken;
	}

	public  void setAdminAccessToken(String adminAccesToken) {
		this.adminAccessToken = adminAccesToken;
	}

	public  Map<String, String> getAuthHeaders() {
		OAuthClientRequest bearerClientRequest = null;
		try {
			bearerClientRequest = new OAuthBearerClientRequest("https://dev.pyramus.fi")
					.setAccessToken(this.getAccessToken()).buildHeaderMessage();
		} catch (OAuthSystemException e) {
		}

		return bearerClientRequest.getHeaders();
	}

	public  Map<String, String> getAdminAuthHeaders() {
		OAuthClientRequest bearerClientRequest = null;
		try {
			bearerClientRequest = new OAuthBearerClientRequest("https://dev.pyramus.fi")
					.setAccessToken(this.getAdminAccessToken()).buildHeaderMessage();
		} catch (OAuthSystemException e) {
		}
		return bearerClientRequest.getHeaders();
	}

	public  Long getUserIdForRole(String role) {
		// TODO: could this use the /system/whoami end-point?
		return Common.getUserId(Common.strToRole(role));
	}

  public  boolean roleIsAllowed(String role, PyramusPermissionCollection permissionCollection, String permission) throws NoSuchFieldException {
    List<String> allowedRoles = Arrays.asList(permissionCollection.getDefaultRoles(permission));

    return roleIsAllowed(getRole(), allowedRoles);
  }
	
	public  boolean roleIsAllowed(String role, List<String> allowedRoles) {
		// Everyone -> every role has access
		if (allowedRoles.contains(Role.EVERYONE.name()))
			return true;

		for (String str : allowedRoles) {
			if (str.equals(role)) {
				return true;
			}
		}
		return false;
	}

	public  void assertOk(String path, List<String> allowedRoles) {
		if (!Role.EVERYONE.name().equals(getRole())) {
			if (roleIsAllowed(getRole(), allowedRoles)) {
				given().headers(getAuthHeaders()).get(path).then().assertThat().statusCode(200);
			} else {
				given().headers(getAuthHeaders()).get(path).then().assertThat().statusCode(403);
			}
		} else
			given().headers(getAuthHeaders()).get(path).then().assertThat().statusCode(400);
	}

	public  void assertOk(Response response, PyramusPermissionCollection permissionCollection, String permission)
			throws NoSuchFieldException {
		assertOk(response, permissionCollection, permission, 200);
	}

	public  void assertOk(Response response, PyramusPermissionCollection permissionCollection, String permission,
			int successStatusCode) throws NoSuchFieldException {
		if (!Role.EVERYONE.name().equals(getRole())) {
			int expectedStatusCode = roleIsAllowed(getRole(), permissionCollection, permission) ? successStatusCode : 403;

			assertThat(
					String.format("Status code <%d> didn't match expected code <%d> when Role = %s, Permission = %s",
							response.statusCode(), expectedStatusCode, getRole(), permission),
					response.statusCode(), is(expectedStatusCode));
		} else
			response.then().assertThat().statusCode(400);
	}

	public static  List<Object[]> getGeneratedRoleData() {
		// The parameter generator returns a List of
		// arrays. Each array has two elements: { role }.

		List<Object[]> data = new ArrayList<>();

		for (Role role : Role.values()) {
			data.add(new Object[] { role.name() });
		}

		return data;

		// return Arrays.asList(new Object[][] {
		// { Role.EVERYONE.name() },
		// { Role.GUEST.name() },
		// { Role.USER.name() },
		// { Role.STUDENT.name() },
		// { Role.MANAGER.name() },
		// { Role.ADMINISTRATOR.name() }
		// }
		// );
	}

	protected  String getRole() {
		return role;
	}

	protected  void setRole(String role) {
		this.role = role;
	}

	protected String role;
	private String accessToken;
	private String adminAccessToken;
}
=========================
package br.ufrn.imd.fiware.security.servlet;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.codec.binary.Base64;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthAuthzResponse;
import org.apache.oltu.oauth2.client.response.OAuthJSONAccessTokenResponse;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;

public class AuthServlet extends HttpServlet {

	private static final long serialVersionUID = 1L;
	
	private static final String CLIENT_SECRET = "934ab80355744d6a9973310239746e12";
	private static final String CLIENT_ID = "4cea9033583447459f9b319b661fba6f";
	private static final String BASE_64_ENCODED_STRING = new String(Base64.encodeBase64((CLIENT_ID + ":" + CLIENT_SECRET).getBytes()));
	
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		System.out.println("GET /auth");
		
		try {
			OAuthAuthzResponse oar = OAuthAuthzResponse.oauthCodeAuthzResponse(req);
			String code = oar.getCode();
			System.out.println("Code: " + code);
			
			OAuthClientRequest tokenRequest = OAuthClientRequest
					.tokenLocation("http://10.7.31.29:8000/oauth2/token")
	                .setGrantType(GrantType.AUTHORIZATION_CODE)
	                .setCode(code)
	                .setRedirectURI("http://localhost:8080/Example-Application-Security-UI/auth")
	                .buildBodyMessage();
			
			tokenRequest.setHeader("Authorization", "Basic " + BASE_64_ENCODED_STRING);
			tokenRequest.setHeader("Content-Type", "application/x-www-form-urlencoded");
			
			OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
			OAuthJSONAccessTokenResponse oAuthResponse = oAuthClient.accessToken(tokenRequest);

			String accessToken = oAuthResponse.getAccessToken();
	        Long expiresIn = oAuthResponse.getExpiresIn();
	      
	        System.out.println("Token: " + accessToken);
	        System.out.println("Expires In: " + expiresIn);

	        //Add token on cookies or session

			resp.sendRedirect("http://localhost:8080/Example-Application-Security-UI/");
		} catch (OAuthProblemException e) {
			// TODO Auto-generated catch block
			System.err.println("Error on authentication. Error: " + e.getMessage());
			e.printStackTrace();
		} catch (OAuthSystemException e) {
			// TODO Auto-generated catch block
			System.err.println("Error on authentication. Error: " + e.getMessage());
			e.printStackTrace();
		}
	}

}
===============

<dependency>
			<groupId>org.apache.oltu.oauth2</groupId>
			<artifactId>org.apache.oltu.oauth2.client</artifactId>
			<version>1.0.0</version>
		</dependency>


static String hostname = "[YOUR SHOP NAME].myshopify.com";
static String apiTemplate = "https://%s:%s@%s/admin/%s.json";;

public static String retrieveResource(String resource)
{

String result = null;


try {

URL url = new URL(String.format(apiTemplate, apiKey, password, hostname, resource));

URLConnection conn = url.openConnection();

String userpass = apiKey + ":" + password;
String basicAuth = "Basic " + javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());

conn.setRequestProperty ("Authorization", basicAuth);

InputStream input = conn.getInputStream();

BufferedReader br = null;
StringBuilder sb = new StringBuilder();

String line;

br = new BufferedReader(new InputStreamReader(input));
while ((line = br.readLine()) != null) {
sb.append(line);
}

result = sb.toString();

} catch (Exception e) {
e.printStackTrace();
}

return result;
}

=============================
package com.github.jreddit.request.reddit.oauth;

import java.util.Base64;
import java.util.UUID;

import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest.TokenRequestBuilder;
import org.apache.oltu.oauth2.common.OAuthProviderType;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;

import com.github.jreddit.request.reddit.app.RedditApp;

/**
 * Thread-safe reddit OAuth agent.
 * 
 * Communicates with reddit to retrieve tokens.
 * 
 * @author Simon Kassing
 *
 */
public class RedditOAuthAgent {
	
	/** Grant type for an installed client (weirdly enough a URI). */
    public static final String GRANT_TYPE_INSTALLED_CLIENT = "https://oauth.reddit.com/grants/installed_client";
    
    /** Grant type for client credentials (described in OAuth2 standard). */
    public static final String GRANT_TYPE_CLIENT_CREDENTIALS = "client_credentials";
    
	/** User agent. */
	private final String userAgent;
	
	/** OAuth2 client. */
	private OAuthClient oAuthClient;
	
	/** Reddit application. */
	private RedditApp redditApp;
    
    /*
	OAuthClientRequest request = OAuthClientRequest
            .tokenProvider(OAuthProviderType.REDDIT)
            .setGrantType(GrantType.AUTHORIZATION_CODE)
            
            .setClientId(CLIENT_ID)
            .setClientSecret(CLIENT_SECRET)
            .setRedirectURI(REDIRECT_URI)
            .setParameter("duration", PERMANENT_ACCESS ? "permanent" : "temporary")
            .setScope("scope", PERMANENT_ACCESS ? "permanent" : "temporary")
            .buildQueryMessage();
     */
    
    /**
     * Constructor for a Reddit OAuth agent.
     * 
     * @param userAgent User agent for your application (e.g. "jReddit: Reddit API Wrapper for Java")
     * @param redditApp Reddit application
     */
    public RedditOAuthAgent(String userAgent, RedditApp redditApp) {
    	this.userAgent = userAgent;
    	this.redditApp = redditApp;
    	
    	// Initialize OAuthClient with custom HTTPClient under the hood
    	this.oAuthClient = new OAuthClient(new URLConnectionClient());
    	
    }
    
    /**
     * Add a user agent to the OAuth request.
     * 
     * @param request OAuth request
     */
    private void addUserAgent(OAuthClientRequest request) {
    	request.addHeader("User-Agent", userAgent);
    }
    
    /**
     * Add the basic authentication protocol to the OAuth request using
     * the credentials of the Reddit application provided.
     * 
     * @param request OAuth request
     * @param app Reddit application
     */
    private void addBasicAuthentication(OAuthClientRequest request, RedditApp app) {
		String authString = app.getClientID() + ":" + app.getClientSecret();
		byte[] authEncBytes = Base64.getEncoder().encode(authString.getBytes());
		String authStringEnc = new String(authEncBytes);
		request.addHeader("Authorization", "Basic " + authStringEnc);
    }
    
    /**
     * Token retrieval (<i>code</i> flow).<br>
     * <br>
     * Retrieve a token for a specific user, meaning that the token is <u>coupled to a user</u>. 
     * After it has expired, the token will no longer work. You must either request a new
     * token, or refresh it using {@link #refreshToken()}.
     * 
     * @param app Application
     * @param code One-time code received from the user, after manual authorization by that user
     * 
     * @return Token (associated with a user)
     * 
     * @throws OAuthSystemException
     * @throws OAuthProblemException
     */
	public synchronized RedditToken token(String code) throws OAuthSystemException, OAuthProblemException {
		
		// Set general values of the request
		OAuthClientRequest request = OAuthClientRequest
            .tokenProvider(OAuthProviderType.REDDIT)
            .setGrantType(GrantType.AUTHORIZATION_CODE)
            .setClientId(redditApp.getClientID())
            .setClientSecret(redditApp.getClientSecret())
            .setRedirectURI(redditApp.getRedirectURI())
            .setParameter("code", code)
            .buildBodyMessage();
		
		// Add the user agent
		addUserAgent(request);
		
		// Add basic authentication
		addBasicAuthentication(request, redditApp);
        
        // Return a wrapper controlled by jReddit
        return new RedditToken(oAuthClient.accessToken(request));

	}
	
    /**
     * Refresh token.<br>
     * <br>
     * This is <u>only</u> possible for tokens retrieved through the <u>code flow</u>
     * authorization and had their duration set to permanent. Tokens that do not have
     * a refresh_token with them or are expired, will not be able to be refreshed. 
     * In that case, a new one must be acquired. 
     * 
     * @param app Application
     * @param rToken Reddit token (which needs to be refreshed)
     * 
     * @return Whether the token was successfully refreshed
     * 
     * @throws OAuthSystemException
     * @throws OAuthProblemException
     * 
     * @see RedditToken#isRefreshable()
     */
	public synchronized boolean refreshToken(RedditToken rToken) throws OAuthSystemException, OAuthProblemException {
		
		// Check whether the token can be refreshed
		if (rToken.isRefreshable()) {
		
			// Set general values of the request
			OAuthClientRequest request = OAuthClientRequest
	            .tokenProvider(OAuthProviderType.REDDIT)
	            .setGrantType(GrantType.REFRESH_TOKEN)
	            .setRefreshToken(rToken.getRefreshToken())
	            .buildBodyMessage();
			
			// Add the user agent
			addUserAgent(request);
			
			// Add basic authentication
			addBasicAuthentication(request, redditApp);
	        
	        // Return a wrapper controlled by jReddit
	        rToken.refresh(oAuthClient.accessToken(request));
	        
	        return true;
        
		} else {
			
			// The token cannot be refreshed
			return false;
			
		}
        
	}
    
    /**
     * Token retrieval (<i>app-only</i> flow).<br>
     * <br>
     * Retrieve a token for the <u>application-only</u>, meaning that the
     * token is <u>not coupled to any user</u>. The token is typically only
     * <u>valid for a short period of time</u> (at the moment of writing: 1 hour).
     * After it has expired, the token will no longer work. You must request a <u>new</u>
     * token in that case. Refreshing an application-only token is not possible.
     * 
     * @param app Application
     * @param confidential <i>True</i>: confidential clients (web apps / scripts) not acting on behalf of one or more logged out users. <i>False</i>: installed app types, and other apps acting on behalf of one or more logged out users.
     * 
     * @return Token (not associated with a user)
     * 
     * @throws OAuthSystemException
     * @throws OAuthProblemException
     */
	public synchronized RedditToken tokenAppOnly(boolean confidential) throws OAuthSystemException, OAuthProblemException {
		
		// Set general values of the request
		TokenRequestBuilder builder = OAuthClientRequest
            .tokenProvider(OAuthProviderType.REDDIT)
            .setParameter("grant_type", confidential ? GRANT_TYPE_CLIENT_CREDENTIALS : GRANT_TYPE_INSTALLED_CLIENT)
            .setClientId(redditApp.getClientID())
            .setClientSecret(redditApp.getClientSecret());
		
		// If it is not acting on behalf of a unique client, a (unique as possible) device identifier must be generated:
		if (!confidential) {
			builder = builder.setParameter("device_id", UUID.randomUUID().toString());
		}
		
		// Build the request
		OAuthClientRequest request = builder.buildBodyMessage();
		
		// Add the user agent
		addUserAgent(request);
		
		// Add basic authentication
		addBasicAuthentication(request, redditApp);
        
        // Return a wrapper controlled by jReddit
        return new RedditToken(oAuthClient.accessToken(request));
        
	}
	
}

==================

/**
 * The MIT License
 * Copyright (c) 2016 Population Register Centre
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package fi.vm.kapa.rova.client.webapi.impl;

import com.fasterxml.jackson.databind.JavaType;
import fi.vm.kapa.rova.client.model.YpaOrganization;
import fi.vm.kapa.rova.client.webapi.*;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthResourceResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

public class YpaWebApiJwtRiClient extends AbstractYpaWebApiRiClient implements YpaWebApiJwtClient {

    JwtUtil jwtUtil;

    public YpaWebApiJwtRiClient(WebApiJwtClientConfig config, String delegateId) {
        super(config, delegateId);
        this.jwtUtil = new JwtUtil(config);
    }

    @Override
    public List<YpaOrganization> getCompanies(String requestId) throws WebApiClientException {
        String tokenResponse = getRolesTokenResponse(getRequestPathWithParams(requestId, null, true));
        return jwtUtil.getCompanies(tokenResponse, delegateId);
    }

    @Override
    public List<YpaOrganization> getRoles(String requestId, String organizationId) throws WebApiClientException {
        String tokenResponse = getRolesTokenResponse(getRequestPathWithParams(requestId, organizationId, true));
        return jwtUtil.getCompanies(tokenResponse, delegateId);
    }

    public String getCompaniesToken(String requestId) throws WebApiClientException {
        return getRolesTokenResponse(getRequestPathWithParams(requestId, null, true));
    }

    public String getRolesToken(String requestId, String organizationId) throws WebApiClientException {
        return getRolesTokenResponse(getRequestPathWithParams(requestId, organizationId, true));
    }

    public String getCompaniesSessionToken(String requestId) throws WebApiClientException {
        return getRolesTokenResponse(getSessionTokenPathWithParams(requestId));
    }

    @Override
    public List<YpaOrganization> getSessionCompanies(String jwtString, String requestId) throws WebApiClientException {
        return getRolesResponse(getSessionCompaniesPathWithParams(jwtString, requestId));
    }

    public String getRolesTokenResponse(String pathWithParams) throws WebApiClientException {
        String result = null;
        OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
        try {
            OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest(new URL(config.getBaseUrl(), pathWithParams).toString()).setAccessToken(accessToken).buildQueryMessage();
            bearerClientRequest.setHeader("X-AsiointivaltuudetAuthorization", getAuthorizationValue(bearerClientRequest.getLocationUri().substring(config.getBaseUrl().toString().length())));

            OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);
            result = resourceResponse.getBody();
        } catch (IOException | OAuthProblemException | OAuthSystemException e) {
            handleException(e);
        }
        return result;
    }

    private List<YpaOrganization> getRolesResponse(String pathWithParams) throws WebApiClientException {
        List<YpaOrganization> result = null;
        try {
            String responseString = getRolesTokenResponse(pathWithParams);
            JavaType resultType = mapper.getTypeFactory().constructParametricType(ArrayList.class, YpaOrganization.class);
            result = mapper.readValue(responseString, resultType);
        } catch (IOException e) {
            handleException(e);
        }
        return result;
    }

    protected String getSessionCompaniesPathWithParams(String jwtString, String requestId) {
        String base = "/service/ypa/jwt/api/organizationRoles/";
        return getPathWithParams(base + jwtString + "/", requestId);
    }

    protected String getSessionTokenPathWithParams(String requestId) {
        String base = "/service/ypa/api/organizationRoles/session/jwt/";
        return getPathWithParams(base + getOauthSessionId(), requestId);
    }
}
===========================

/**
 * The MIT License
 * Copyright (c) 2016 Population Register Centre
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package fi.vm.kapa.rova.client.webapi.impl;

import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import fi.vm.kapa.rova.client.model.Principal;
import fi.vm.kapa.rova.client.webapi.HpaWebApiClient;
import fi.vm.kapa.rova.client.webapi.WebApiClientConfig;
import fi.vm.kapa.rova.client.webapi.WebApiClientException;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthResourceResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public abstract class AbstractHpaWebApiRiClient extends AbstractWebApiRiClient implements HpaWebApiClient {
    protected ObjectMapper mapper = new ObjectMapper();

    public AbstractHpaWebApiRiClient(WebApiClientConfig config, String delegateId) {
        super(config, delegateId);
    }

    @Override
    protected String getRegisterUrl() {
        return "/service/hpa/user/register/" + config.getClientId() + "/" + delegateId;
    }

    @Override
    protected String getUnRegisterUrl(String sessionId) {
        return "/service/hpa/user/unregister/" + sessionId;
    }

    protected String getTransferUrl(String sessionId) {
        return "/service/hpa/user/transfer/token/" + sessionId;
    }

    protected String getRegisterTransferUrl(String transferToken) {
//    	try {
    		//String encodedTransferToken = URLEncoder.encode(transferToken, StandardCharsets.ISO_8859_1.toString());
    		return "/service/hpa/user/register/transfer/" + transferToken + "/" + config.getClientId() + "/" + delegateId;
//    	} catch(UnsupportedEncodingException e) {
//    	    throw new AssertionError(e);
//    	}
    }

    @Override
    public List<Principal> getPrincipals(String requestId) throws WebApiClientException {
        List<Principal> result = null;
        try {
            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
            String pathWithParams = getPathWithParams("/service/hpa/api/delegate/" + getOauthSessionId(), requestId);

            OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest(new URL(config.getBaseUrl(), pathWithParams).toString()).setAccessToken(accessToken).buildQueryMessage();
            bearerClientRequest.setHeader("X-AsiointivaltuudetAuthorization", getAuthorizationValue(bearerClientRequest.getLocationUri().substring(config.getBaseUrl().toString().length())));

            OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);

            JavaType resultType = mapper.getTypeFactory().constructParametricType(ArrayList.class, Principal.class);
            return mapper.readValue(resourceResponse.getBody(), resultType);
        } catch (IOException | OAuthSystemException | OAuthProblemException e) {
            handleException(e);
        }
        return result;
    }

}

==========

/**
 * The MIT License
 * Copyright (c) 2016 Population Register Centre
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package fi.vm.kapa.rova.client.webapi.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import fi.vm.kapa.rova.client.model.Authorization;
import fi.vm.kapa.rova.client.model.AuthorizationList;
import fi.vm.kapa.rova.client.webapi.WebApiClientConfig;
import fi.vm.kapa.rova.client.webapi.WebApiClientException;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthResourceResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;

import java.io.IOException;
import java.net.URL;

/**
 * Client implementation for querying possibilities to operate on behalf of another person.
 */
public class HpaWebApiRiClient extends AbstractHpaWebApiRiClient {

    public HpaWebApiRiClient(WebApiClientConfig config, String delegateId) {
        super(config, delegateId);
    }

    private ObjectMapper mapper = new ObjectMapper();

    @Override
    public Authorization getAuthorization(String principalId, String requestId, String... issues)
            throws WebApiClientException {
        Authorization result = null;
        try {
            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
            String pathWithParams = getPathWithParams("/service/hpa/api/authorization/" + getOauthSessionId() + "/" + principalId, requestId, issues);

            OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest(new URL(config.getBaseUrl(), pathWithParams).toString()).setAccessToken(accessToken).buildQueryMessage();
            bearerClientRequest.setHeader("X-AsiointivaltuudetAuthorization", getAuthorizationValue(bearerClientRequest.getLocationUri().substring(config.getBaseUrl().toString().length())));

            OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);

            result = mapper.readValue(resourceResponse.getBody(), Authorization.class);
        } catch (IOException | OAuthProblemException | OAuthSystemException e) {
            handleException(e);
        }
        return result;
    }

    @Override
    public AuthorizationList getAuthorizationList(String principalId, String requestId)
            throws WebApiClientException {
        AuthorizationList result = null;
        try {
            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
            String pathWithParams = getPathWithParams("/service/hpa/api/authorizationlist/" + getOauthSessionId() + "/" + principalId, requestId);

            OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest(new URL(config.getBaseUrl(), pathWithParams).toString()).setAccessToken(accessToken).buildQueryMessage();
            bearerClientRequest.setHeader("X-AsiointivaltuudetAuthorization", getAuthorizationValue(bearerClientRequest.getLocationUri().substring(config.getBaseUrl().toString().length())));

            OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);

            result = mapper.readValue(resourceResponse.getBody(), AuthorizationList.class);
        } catch (IOException | OAuthProblemException | OAuthSystemException e) {
            handleException(e);
        }
        return result;
    }

}

==========

/**
 * The MIT License
 * Copyright (c) 2016 Population Register Centre
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package fi.vm.kapa.rova.client.webapi.impl;

import fi.vm.kapa.rova.client.model.Authorization;
import fi.vm.kapa.rova.client.model.AuthorizationList;
import fi.vm.kapa.rova.client.webapi.HpaWebApiJwtClient;
import fi.vm.kapa.rova.client.webapi.JwtUtil;
import fi.vm.kapa.rova.client.webapi.WebApiClientException;
import fi.vm.kapa.rova.client.webapi.WebApiJwtClientConfig;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthResourceResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;

import java.io.IOException;
import java.net.URL;

/**
 * Client implementation for querying possibilities to operate on behalf of another person.
 */
public class HpaWebApiJwtRiClient extends AbstractHpaWebApiRiClient implements HpaWebApiJwtClient {

    private WebApiJwtClientConfig jwtConfig;
    private JwtUtil jwtUtil;

    public HpaWebApiJwtRiClient(WebApiJwtClientConfig config, String delegateId) {
        super(config, delegateId);
        this.jwtConfig = config;
        this.jwtUtil = new JwtUtil(jwtConfig);
    }

    @Override
    public Authorization getAuthorization(String principalId, String requestId, String... issues) throws WebApiClientException {
        String jwtString = getAuthorizationToken(principalId, requestId, issues);
        return jwtUtil.getAuthorization(jwtString, principalId);
    }

    @Override
    public AuthorizationList getAuthorizationList(String principalId, String requestId)
            throws WebApiClientException {
        String jwtString = getAuthorizationListToken(principalId, requestId);
        return jwtUtil.getAuthorizationList(jwtString, principalId);
    }

    @Override
    public String getAuthorizationToken(String principalId, String requestId, String... issues) throws WebApiClientException {
        try {
            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
            String pathWithParams = getPathWithParams("/service/hpa/api/authorization/jwt/" + getOauthSessionId() + "/" + principalId, requestId, issues);

            OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest(new URL(config.getBaseUrl(), pathWithParams).toString()).setAccessToken(accessToken).buildQueryMessage();
            bearerClientRequest.setHeader("X-AsiointivaltuudetAuthorization", getAuthorizationValue(bearerClientRequest.getLocationUri().substring(config.getBaseUrl().toString().length())));

            OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);
            return resourceResponse.getBody();
        } catch (IOException | OAuthProblemException | OAuthSystemException e) {
            handleException(e);
        }
        handleException(new WebApiClientException("Could not get Authorization token"));
        // should not get here
        return null;
    }

    @Override
    public String getAuthorizationListToken(String principalId, String requestId) throws WebApiClientException {
        try {
            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
            String pathWithParams = getPathWithParams("/service/hpa/api/authorizationlist/jwt/" + getOauthSessionId() + "/" + principalId, requestId);

            OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest(new URL(config.getBaseUrl(), pathWithParams).toString()).setAccessToken(accessToken).buildQueryMessage();
            bearerClientRequest.setHeader("X-AsiointivaltuudetAuthorization", getAuthorizationValue(bearerClientRequest.getLocationUri().substring(config.getBaseUrl().toString().length())));

            OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);

            return resourceResponse.getBody();
        } catch (IOException | OAuthProblemException | OAuthSystemException e) {
            handleException(e);
        }
        handleException(new WebApiClientException("Could not get AuthorizationList token"));
        // should not get here
        return null;
    }


}

=========
/**
 * The MIT License
 * Copyright (c) 2016 Population Register Centre
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package fi.vm.kapa.rova.client.webapi.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import fi.vm.kapa.rova.client.webapi.WebApiClientConfig;
import fi.vm.kapa.rova.client.webapi.WebApiClientException;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthJSONAccessTokenResponse;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.UUID;

public abstract class AbstractWebApiRiClient {

    protected final static String HMAC_ALGORITHM = "HmacSHA256";
    protected final WebApiClientConfig config;
    protected final String delegateId;

    private RegisterToken registerToken;

    protected String accessToken;

    private String stateParameter = UUID.randomUUID().toString();

    private static class RegisterToken {
        String sessionId;
        String userId;

        @SuppressWarnings("unused")
        void setSessionId(String sessionId) {
            this.sessionId = sessionId;
        }

        @SuppressWarnings("unused")
        void setUserId(String userId) {
            this.userId = userId;
        }
    }

    private boolean clientActiveState;

    public AbstractWebApiRiClient(WebApiClientConfig config, String delegateId) {
        this.config = config;
        this.delegateId = delegateId;
    }

    protected abstract String getRegisterUrl();

    protected abstract String getUnRegisterUrl(String sessionId);

    protected abstract String getTransferUrl(String sessionId);

    protected abstract String getRegisterTransferUrl(String transferToken);

    public void getToken(String codeParam, String stateParam) throws WebApiClientException {
        if (!stateParameter.equals(stateParam)) {
            clientActiveState = false;
            throw new WebApiClientException("Mismatching OAuth state parameter. Expected state=" + stateParameter);
        }

        OAuthJSONAccessTokenResponse oAuthResponse = null;
        try {
            OAuthClientRequest.TokenRequestBuilder requestBuilder = OAuthClientRequest.tokenLocation(config.getTokenUrl()).setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(config.getClientId()).setClientSecret(config.getoAuthSecret()).setCode(codeParam);

            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());
            oAuthResponse = oAuthClient.accessToken(requestBuilder.setRedirectURI(config.getoAuthRedirect()).buildBodyMessage(), OAuthJSONAccessTokenResponse.class);
        } catch (OAuthProblemException | OAuthSystemException e) {
            handleException("Unable to get token", e);
        }
        this.accessToken = oAuthResponse.getAccessToken();
    }

    public String getTransferToken() throws WebApiClientException {
        try {
            String sessionId = this.registerToken.sessionId;
            if (sessionId == null) {
                throw new WebApiClientException("No active session found for transfer.");
            }
            return getResultString(getTransferUrl(sessionId));
        } catch (IOException e) {
            handleException("Transfer Token fetching failed", e);
        }
        return null;
    }

    public String registerTransfer(String transferToken, String requestId, String userInterfaceLanguage) throws WebApiClientException {
        return actuallyRegister(getRegisterTransferUrl(transferToken), requestId, userInterfaceLanguage);
    }

    public String register(String requestId, String userInterfaceLanguage) throws WebApiClientException {
        return actuallyRegister(getRegisterUrl(), requestId, userInterfaceLanguage);
    }

    private String actuallyRegister(String path, String requestId, String userInterfaceLanguage) throws WebApiClientException {
        try {
            clientActiveState = true;
            String tokenStr = getResultString(getPathWithParams(path, requestId));
            ObjectMapper mapper = new ObjectMapper();
            this.registerToken = mapper.readValue(tokenStr, RegisterToken.class);

            return config.getAuthorizeUrl() //
                    + "?client_id=" + config.getClientId() //
                    + "&response_type=code"//
                    + "&requestId=" + requestId//
                    + "&user=" + this.registerToken.userId //
                    + "&state=" + stateParameter //
                    + "&redirect_uri=" + config.getoAuthRedirect() //
                    + (userInterfaceLanguage != null ? "&lang=" + userInterfaceLanguage : "");
        } catch (IOException e) {
            handleException(e);
        }
        // should not get here
        return null;
    }

    public Boolean unregister() throws WebApiClientException {
        clientActiveState = false;
        try {
            String sessionId = this.registerToken.sessionId;
            if (sessionId == null) {
                return false;
            }
            String resultString = getResultString(getUnRegisterUrl(sessionId));
            return (resultString != null && "true".equalsIgnoreCase(resultString));
        } catch (IOException e) {
            handleException("Unregisterig failed", e);
        }
        return false;
    }

    protected String getOauthSessionId() {
        return registerToken.sessionId;
    }

    protected String getAuthorizationValue(String path) throws IOException {
        String timestamp = ZonedDateTime.now(ZoneOffset.UTC).format(DateTimeFormatter.ISO_DATE_TIME);
        return config.getClientId() + " " + timestamp + " " + hash(path + " " + timestamp, config.getApiKey());
    }

    @SuppressWarnings("Duplicates")
    private String hash(String data, String key) throws IOException {
        try {
            Mac mac = Mac.getInstance(HMAC_ALGORITHM);
            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_ALGORITHM);
            mac.init(signingKey);
            byte[] rawHmac = mac.doFinal(data.getBytes());
            String result = new String(Base64.getEncoder().encode(rawHmac));
            return result;
        } catch (NoSuchAlgorithmException | InvalidKeyException | IllegalStateException e) {
            throw new IOException("Cannot create hash", e);
        }
    }

    protected String getPathWithParams(String path, String requestId, String... issues) {
        StringBuilder pathBuilder = new StringBuilder(path).append("?requestId=").append(requestId);
        for (String issue : issues) {
            if (issue != null) {
                pathBuilder.append("&issues=").append(issue);
            }
        }

        return pathBuilder.toString();
    }

    protected void handleException(Throwable t) throws WebApiClientException {
        clientActiveState = false;
        throw new WebApiClientException("Got exception client now in inactive state", t);
    }

    protected void handleException(String msg, Throwable t) throws WebApiClientException {
        clientActiveState = false;
        throw new WebApiClientException(msg, t);
    }

    private String getResultString(String path) throws IOException {
        URL url = new URL(config.getBaseUrl(), path);
        HttpURLConnection yc = (HttpURLConnection) url.openConnection();
        yc.setRequestProperty("X-AsiointivaltuudetAuthorization", getAuthorizationValue(path));
        String resultString = null;
        try (BufferedReader in = new BufferedReader(new InputStreamReader(yc.getInputStream()))) {
            String s;
            while ((s = in.readLine()) != null) {
                resultString = s;
            }
        }
        return resultString;
    }

    public String getDelegateId() {
        return this.delegateId;
    }
}

=======
URI location = new URI(request.getLocationUri());
HttpRequestBase req = null;
InputStream responseBody = new ByteArrayInputStream(new byte[0]);
  HttpEntity entity = new StringEntity(request.getBody());
  ((HttpPost)req).setEntity(entity);
} else {
if (request.getHeaders() != null) {
  for (Map.Entry<String, String> header : request.getHeaders().entrySet()) {
    req.setHeader(header.getKey(), header.getValue());
	}
	
--------------------------------------------------------------------------------------------------------	
	accessTokenRequest = OAuthClientRequest.tokenLocation(tokenEndPoint).setGrantType(GrantType
      .AUTHORIZATION_CODE).setRedirectURI(callbackUrl).setCode(authzResponse.getCode())
      .buildBodyMessage();
  String base64EncodedCredential = Base64.encodeBase64URLSafeString(new String(clientId + ":" +
      clientSecret).getBytes());
  accessTokenRequest.addHeader(OAuth.HeaderType.AUTHORIZATION, "Basic " + base64EncodedCredential);
} else {
  accessTokenRequest = OAuthClientRequest.tokenLocation(tokenEndPoint).setGrantType(GrantType
      .AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret).setRedirectURI
      (callbackUrl).setCode(authzResponse.getCode()).buildBodyMessage();
	  
	  
---------------------------------------------------------------------------------------------------------	  
	  public static AuthResponse authenticate(String username,String password) throws AuthenticationException {
  try {
    OAuthClientRequest request = OAuthClientRequest.tokenLocation(hostName+"/oauth2/token").
        setClientId(clientId).setClientSecret(clientSecret).
        setGrantType(GrantType.PASSWORD).
          buildQueryMessage();
      ucc = new URLConnectionClient();
      request.setHeader("Authorization","Bearer "+accessToken);
      oAuthClient = new org.apache.oltu.oauth2.client.OAuthClient(ucc);
      resp = oAuthClient.resource(request, OAuth.HttpMethod.GET,
	  
	  -------------------------------------------
	  public OAuth(OAuthFlow flow, String authorizationUrl, String tokenUrl, String scopes) {
  this(OAuthClientRequest.tokenLocation(tokenUrl).setScope(scopes));
  setFlow(flow);
  authenticationRequestBuilder = OAuthClientRequest.authorizationLocation(authorizationUrl);
}

-------------------------------------------------------------------------------------------------------------

public <T extends OAuthClientResponse> T execute(OAuthClientRequest request, Map<String, String> headers,
    String requestMethod, Class<T> responseClass)
        throws OAuthSystemException, OAuthProblemException {
  MediaType mediaType = MediaType.parse("application/json");
  Request.Builder requestBuilder = new Request.Builder().url(request.getLocationUri());
  if(headers != null) {
    for (Entry<String, String> entry : headers.entrySet()) {
      if (entry.getKey().equalsIgnoreCase("Content-Type")) {
        mediaType = MediaType.parse(entry.getValue());
      } else {
        requestBuilder.addHeader(entry.getKey(), entry.getValue());
      }
    }
  }
  RequestBody body = request.getBody() != null ? RequestBody.create(mediaType, request.getBody()) : null;
  requestBuilder.method(requestMethod, body);
  try {
    Response response = client.newCall(requestBuilder.build()).execute();
    return OAuthClientResponseFactory.createCustomResponse(
        response.body().string(), 
        response.body().contentType().toString(),
        response.code(),
        responseClass);
  } catch (IOException e) {
    throw new OAuthSystemException(e);
  }
}


========================

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpHeaders;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.methods.RequestBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.util.EntityUtils;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthJSONAccessTokenResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import gobblin.converter.http.RestEntry;
import gobblin.writer.exception.NonTransientException;

/**
 * Writes to Salesforce via RESTful API, supporting INSERT_ONLY_NOT_EXIST, and UPSERT.
 *
 */
public class SalesforceRestWriter extends RestJsonWriter {
  public static enum Operation {
    INSERT_ONLY_NOT_EXIST,
    UPSERT
  }
  static final String DUPLICATE_VALUE_ERR_CODE = "DUPLICATE_VALUE";

  private String accessToken;

  private final URI oauthEndPoint;
  private final String clientId;
  private final String clientSecret;
  private final String userId;
  private final String password;
  private final String securityToken;
  private final Operation operation;

  private final int batchSize;
  private final Optional<String> batchResourcePath;
  private Optional<JsonArray> batchRecords = Optional.absent();
  private long numRecordsWritten = 0L;

  public  SalesforceRestWriter(SalesForceRestWriterBuilder builder) {
    super(builder);

    this.oauthEndPoint = builder.getSvcEndpoint().get(); //Set oauth end point
    this.clientId = builder.getClientId();
    this.clientSecret = builder.getClientSecret();
    this.userId = builder.getUserId();
    this.password = builder.getPassword();
    this.securityToken = builder.getSecurityToken();
    this.operation = builder.getOperation();
    this.batchSize = builder.getBatchSize();
    this.batchResourcePath = builder.getBatchResourcePath();
    Preconditions.checkArgument(batchSize == 1 || batchResourcePath.isPresent(), "Batch resource path is missing");
    if (batchSize > 1) {
      getLog().info("Batch api will be used with batch size " + batchSize);
    }
    try {
      onConnect(oauthEndPoint);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @VisibleForTesting
   SalesforceRestWriter(SalesForceRestWriterBuilder builder, String accessToken) {
    super(builder);

    this.oauthEndPoint = builder.getSvcEndpoint().get(); //Set oauth end point
    this.clientId = builder.getClientId();
    this.clientSecret = builder.getClientSecret();
    this.userId = builder.getUserId();
    this.password = builder.getPassword();
    this.securityToken = builder.getSecurityToken();
    this.operation = builder.getOperation();
    this.batchSize = builder.getBatchSize();
    this.batchResourcePath = builder.getBatchResourcePath();
    Preconditions.checkArgument(batchSize == 1 || batchResourcePath.isPresent(), "Batch resource path is missing");

    this.accessToken = accessToken;
  }

  /**
   * Retrieve access token, if needed, retrieve instance url, and set server host URL
   * {@inheritDoc}
   * @see gobblin.writer.http.HttpWriter#onConnect(org.apache.http.HttpHost)
   */
  @Override
  public  void onConnect(URI serverHost) throws IOException {
    if (!StringUtils.isEmpty(accessToken)) {
      return; //No need to be called if accessToken is active.
    }

    try {
      getLog().info("Getting Oauth2 access token.");
      OAuthClientRequest request = OAuthClientRequest.tokenLocation(serverHost.toString())
          .setGrantType(GrantType.PASSWORD)
          .setClientId(clientId)
          .setClientSecret(clientSecret)
          .setUsername(userId)
          .setPassword(password + securityToken).buildQueryMessage();
      OAuthClient client = new OAuthClient(new URLConnectionClient());
      OAuthJSONAccessTokenResponse response = client.accessToken(request, OAuth.HttpMethod.POST);

      accessToken = response.getAccessToken();
      setCurServerHost(new URI(response.getParam("instance_url")));
    } catch (OAuthProblemException e) {
      throw new NonTransientException("Error while authenticating with Oauth2", e);
    } catch (OAuthSystemException e) {
      throw new RuntimeException("Failed getting access token", e);
    } catch (URISyntaxException e) {
      throw new RuntimeException("Failed due to invalid instance url", e);
    }
  }

  /**
   * For single request, creates HttpUriRequest and decides post/patch operation based on input parameter.
   *
   * For batch request, add the record into JsonArray as a subrequest and only creates HttpUriRequest with POST method if it filled the batch size.
   * {@inheritDoc}
   * @see gobblin.writer.http.RestJsonWriter#onNewRecord(gobblin.converter.rest.RestEntry)
   */
  @Override
  public  Optional<HttpUriRequest> onNewRecord(RestEntry<JsonObject> record) {
    Preconditions.checkArgument(!StringUtils.isEmpty(accessToken), "Access token has not been acquired.");
    Preconditions.checkNotNull(record, "Record should not be null");

    RequestBuilder builder = null;
    JsonObject payload = null;

    if (batchSize > 1) {
      if (!batchRecords.isPresent()) {
        batchRecords = Optional.of(new JsonArray());
      }
      batchRecords.get().add(newSubrequest(record));

      if (batchRecords.get().size() < batchSize) { //No need to send. Return absent.
        return Optional.absent();
      }

      payload = newPayloadForBatch();
      builder = RequestBuilder.post().setUri(combineUrl(getCurServerHost(), batchResourcePath));
    } else {
      switch (operation) {
        case INSERT_ONLY_NOT_EXIST:
          builder = RequestBuilder.post();
          break;
        case UPSERT:
          builder = RequestBuilder.patch();
          break;
        default:
          throw new IllegalArgumentException(operation + " is not supported.");
      }
      builder.setUri(combineUrl(getCurServerHost(), record.getResourcePath()));
      payload = record.getRestEntryVal();
    }
    return Optional.of(newRequest(builder, payload));
  }

  /**
   * Create batch subrequest. For more detail @link https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/requests_composite_batch.htm
   *
   * @param record
   * @return
   */
  private  JsonObject newSubrequest(RestEntry<JsonObject> record) {
    Preconditions.checkArgument(record.getResourcePath().isPresent(), "Resource path is not defined");
    JsonObject subReq = new JsonObject();
    subReq.addProperty("url", record.getResourcePath().get());
    subReq.add("richInput", record.getRestEntryVal());

    switch (operation) {
      case INSERT_ONLY_NOT_EXIST:
        subReq.addProperty("method", "POST");
        break;
      case UPSERT:
        subReq.addProperty("method", "PATCH");
        break;
      default:
        throw new IllegalArgumentException(operation + " is not supported.");
    }
    return subReq;
  }
  /**
   * @return JsonObject contains batch records
   */
  private  JsonObject newPayloadForBatch() {
    JsonObject payload = new JsonObject();
    payload.add("batchRequests", batchRecords.get());
    return payload;
  }

  private  HttpUriRequest newRequest(RequestBuilder builder, JsonElement payload) {
    try {
      builder.addHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType())
             .addHeader(HttpHeaders.AUTHORIZATION, "OAuth " + accessToken)
             .setEntity(new StringEntity(payload.toString(), ContentType.APPLICATION_JSON));
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
    if (getLog().isDebugEnabled()) {
      getLog().debug("Request builder: " + ToStringBuilder.reflectionToString(builder, ToStringStyle.SHORT_PREFIX_STYLE));
    }
    return builder.build();
  }

  @Override
  public  void flush() {
    try {
      if (isRetry()) {
        //flushing failed and it should be retried.
        super.writeImpl(null);
        return;
      }

      if (batchRecords.isPresent() && batchRecords.get().size() > 0) {
        getLog().info("Flusing remaining subrequest of batch. # of subrequests: " + batchRecords.get().size());
        curRequest = Optional.of(newRequest(RequestBuilder.post().setUri(combineUrl(getCurServerHost(), batchResourcePath)),
                                                newPayloadForBatch()));
        super.writeImpl(null);
      }
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * Make it fail (throw exception) if status code is greater or equal to 400 except,
   * the status code is 400 and error code is duplicate value, regard it as success(do not throw exception).
   *
   * If status code is 401 or 403, re-acquire access token before make it fail -- retry will take care of rest.
   *
   * {@inheritDoc}
   * @see gobblin.writer.http.HttpWriter#processResponse(org.apache.http.HttpResponse)
   */
  @Override
  public  void processResponse(CloseableHttpResponse response) throws IOException, UnexpectedResponseException {
    if (getLog().isDebugEnabled()) {
      getLog().debug("Received response " + ToStringBuilder.reflectionToString(response, ToStringStyle.SHORT_PREFIX_STYLE));
    }

    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode == 401 || statusCode == 403) {
      getLog().info("Reacquiring access token.");
      accessToken = null;
      onConnect(oauthEndPoint);
      throw new RuntimeException("Access denied. Access token has been reacquired and retry may solve the problem. "
                                 + ToStringBuilder.reflectionToString(response, ToStringStyle.SHORT_PREFIX_STYLE));

    }
    if (batchSize > 1) {
      processBatchRequestResponse(response);
      numRecordsWritten += batchRecords.get().size();
      batchRecords = Optional.absent();
    } else {
      processSingleRequestResponse(response);
      numRecordsWritten++;
    }
  }

  private  void processSingleRequestResponse(CloseableHttpResponse response) throws IOException,
      UnexpectedResponseException {
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode < 400) {
      return;
    }
    String entityStr = EntityUtils.toString(response.getEntity());
    if (statusCode == 400
        && Operation.INSERT_ONLY_NOT_EXIST.equals(operation)
        && entityStr != null) { //Ignore if it's duplicate entry error code

      JsonArray jsonArray = new JsonParser().parse(entityStr).getAsJsonArray();
      JsonObject jsonObject = jsonArray.get(0).getAsJsonObject();
      if (isDuplicate(jsonObject, statusCode)) {
        return;
      }
    }
    throw new RuntimeException("Failed due to " + entityStr + " (Detail: "
        + ToStringBuilder.reflectionToString(response, ToStringStyle.SHORT_PREFIX_STYLE) + " )");
  }

  /**
   * Check results from batch response, if any of the results is failure throw exception.
   * @param response
   * @throws IOException
   * @throws UnexpectedResponseException
   */
  private  void processBatchRequestResponse(CloseableHttpResponse response) throws IOException,
      UnexpectedResponseException {
    String entityStr = EntityUtils.toString(response.getEntity());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode >= 400) {
      throw new RuntimeException("Failed due to " + entityStr + " (Detail: "
          + ToStringBuilder.reflectionToString(response, ToStringStyle.SHORT_PREFIX_STYLE) + " )");
    }

    JsonObject jsonBody = new JsonParser().parse(entityStr).getAsJsonObject();
    if (!jsonBody.get("hasErrors").getAsBoolean()) {
      return;
    }

    JsonArray results = jsonBody.get("results").getAsJsonArray();
    for (JsonElement jsonElem : results) {
      JsonObject json = jsonElem.getAsJsonObject();
      int subStatusCode = json.get("statusCode").getAsInt();
      if (subStatusCode < 400) {
        continue;
      } else if (subStatusCode == 400
                 && Operation.INSERT_ONLY_NOT_EXIST.equals(operation)) {
        JsonElement resultJsonElem = json.get("result");
        Preconditions.checkNotNull(resultJsonElem, "Error response should contain result property");
        JsonObject resultJsonObject = resultJsonElem.getAsJsonArray().get(0).getAsJsonObject();
        if (isDuplicate(resultJsonObject, subStatusCode)) {
          continue;
        }
      }
      throw new RuntimeException("Failed due to " + jsonBody + " (Detail: "
          + ToStringBuilder.reflectionToString(response, ToStringStyle.SHORT_PREFIX_STYLE) + " )");
    }
  }

  private  boolean isDuplicate(JsonObject responseJsonObject, int statusCode) {
    return statusCode == 400
           && Operation.INSERT_ONLY_NOT_EXIST.equals(operation)
           && DUPLICATE_VALUE_ERR_CODE.equals(responseJsonObject.get("errorCode").getAsString());
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public  long recordsWritten() {
    return this.numRecordsWritten;
  }
}

==================================================================================
import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeSet;

import javax.servlet.http.HttpServletRequest;

import org.apache.oltu.oauth2.client.HttpClient;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.GitHubTokenResponse;
import org.apache.oltu.oauth2.client.response.OAuthAccessTokenResponse;
import org.apache.oltu.oauth2.client.response.OAuthAuthzResponse;
import org.apache.oltu.oauth2.client.response.OAuthClientResponse;
import org.apache.oltu.oauth2.client.response.OAuthClientResponseFactory;
import org.apache.oltu.oauth2.client.response.OAuthJSONAccessTokenResponse;
import org.apache.oltu.oauth2.client.response.OAuthResourceResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.OAuthProviderType;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;
import org.apache.oltu.oauth2.common.utils.OAuthUtils;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import com.venky.core.util.ObjectUtil;
import com.venky.swf.controller.annotations.RequireLogin;
import com.venky.swf.db.Database;
import com.venky.swf.db.Transaction;
import com.venky.swf.db.model.User;
import com.venky.swf.db.model.UserEmail;
import com.venky.swf.path.Path;
import com.venky.swf.routing.Config;
import com.venky.swf.sql.Expression;
import com.venky.swf.sql.Operator;
import com.venky.swf.sql.Select;
import com.venky.swf.views.HtmlView;
import com.venky.swf.views.HtmlView.StatusType;
import com.venky.swf.views.RedirectorView;
import com.venky.swf.views.View;


public class OidController extends Controller{

	public  OidController(Path path) {
		super(path);
	}
	
	static class OIDProvider {
		public OIDProvider(String opendIdProvider, OAuthProviderType providerType,
				String issuer , Class< ? extends OAuthAccessTokenResponse> tokenResponseClass,String resourceUrl) {
			this.iss = issuer ; 
			this.tokenResponseClass = tokenResponseClass;
			this.resourceUrl = resourceUrl;
			this.openIdProvider = opendIdProvider ;  this.providerType = providerType; 
			this.clientId = Config.instance().getClientId(opendIdProvider); 
			this.clientSecret = Config.instance().getClientSecret(opendIdProvider) ; 
			this.redirectUrl = Config.instance().getServerBaseUrl() + "/oid/verify?SELECTED_OPEN_ID="+opendIdProvider;
		}
		String openIdProvider;
		OAuthProviderType providerType;
		String clientId;
		String clientSecret;
		String iss;
		Class<? extends OAuthAccessTokenResponse> tokenResponseClass;
		String resourceUrl;
		String redirectUrl; 
		public  OAuthClientRequest createRequest(){
			try {
				return OAuthClientRequest.authorizationProvider(providerType).setClientId(clientId).setResponseType(OAuth.OAUTH_CODE)
						.setScope("email").
						setRedirectURI(redirectUrl).buildQueryMessage();
			} catch (OAuthSystemException e) {
				throw new RuntimeException(e);
			}
		}
		public  String authorize(String code){
			try {
				OAuthClientRequest oauthRequest = OAuthClientRequest
				        .tokenProvider(providerType)
				        .setGrantType(GrantType.AUTHORIZATION_CODE)
				        .setClientId(clientId)
				        .setClientSecret(clientSecret)
				        .setRedirectURI(redirectUrl)
				        .setCode(code)
				        .setScope("email")
				        .buildBodyMessage();

				OAuthClient oAuthClient = new OAuthClient(new OidHttpClient());

		        OAuthAccessTokenResponse oAuthResponse = oAuthClient.accessToken(oauthRequest, tokenResponseClass);
		        
		        if (ObjectUtil.isVoid(resourceUrl)){
					return extractEmail(oAuthResponse);
		        }else {
		        	String accessToken = oAuthResponse.getAccessToken();
			        Long expiresIn = oAuthResponse.getExpiresIn();
			    	OAuthClientRequest bearerClientRequest = new OAuthBearerClientRequest(resourceUrl)
					         .setAccessToken(accessToken).buildQueryMessage();
					 
					OAuthResourceResponse resourceResponse = oAuthClient.resource(bearerClientRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);
					
					return extractEmail(resourceResponse);
		        }
			} catch (Exception e) {
				throw new RuntimeException(e);
			}		
		}
		public  String extractEmail(OAuthResourceResponse oAuthResponse) throws Exception{
			JSONObject body = (JSONObject) new JSONParser().parse(oAuthResponse.getBody());
			String email =  (String) body.get("email");
			return email;
		}
		public  String extractEmail(OAuthAccessTokenResponse oAuthResponse) throws Exception{
	        if (oAuthResponse instanceof OAuthJSONAccessTokenResponse){
		        String idToken = oAuthResponse.getParam("id_token");
		        StringTokenizer tk = new StringTokenizer(idToken,".");
		        String headerBuf = new String(Base64.getDecoder().decode(tk.nextToken()));
		        String bodyBuf = new String(Base64.getDecoder().decode(tk.nextToken()));
		        JSONObject header = (JSONObject) new JSONParser().parse(headerBuf);
		        JSONObject body = (JSONObject) new JSONParser().parse(bodyBuf);
		        
		        String emailId = (String) body.get("email");
		        String[] issuers = new String[] {iss, "http://" + iss , "https://" + iss };
		        
		        if (body.get("aud").equals(clientId) && Arrays.asList(issuers).contains(body.get("iss"))) {
		        	  return emailId;
		    	}
			}
	        throw new RuntimeException("OAuth Failed");

		}
	 
	}
	private static Map<String,OIDProvider> oidproviderMap = new HashMap<>();
	static { 
		oidproviderMap.put("GOOGLE", new OIDProvider("GOOGLE",OAuthProviderType.GOOGLE,"accounts.google.com",
				OAuthJSONAccessTokenResponse.class,""));
		oidproviderMap.put("FACEBOOK", new OIDProvider("FACEBOOK",OAuthProviderType.FACEBOOK,"",
				GitHubTokenResponse.class,"https://graph.facebook.com/me?fields=email,name"));

	}
	
	@SuppressWarnings("rawtypes")
	protected  View authenticate() {
		String selectedOpenId = getPath().getRequest().getParameter("SELECTED_OPEN_ID");
		
		if (ObjectUtil.isVoid(selectedOpenId)){
			HtmlView lv = createLoginView();
			lv.setStatus(StatusType.ERROR, "Open id provider not specified");
			return lv;
		}
		
		try {
			OAuthClientRequest request = oidproviderMap.get(selectedOpenId).createRequest();
			RedirectorView ret = new RedirectorView(getPath());
			ret.setRedirectUrl(request.getLocationUri());
			return ret;
		} catch (Exception e) {
			return createLoginView(StatusType.ERROR,e.getMessage());
		} 
	}
	
	
	@SuppressWarnings("rawtypes")
	@RequireLogin(false)
	public  View verify() throws OAuthProblemException, OAuthSystemException, ParseException{
		HttpServletRequest request = getPath().getRequest();
		OAuthAuthzResponse oar = OAuthAuthzResponse.oauthCodeAuthzResponse(request);
		String code = oar.getCode();
		
		String selectedOpenId = getPath().getRequest().getParameter("SELECTED_OPEN_ID");
		OIDProvider provider = oidproviderMap.get(selectedOpenId);

		try {
	        String email = provider.authorize(code);
    		User u = null;
			Select select = new Select().from(UserEmail.class);
			select.where(new Expression(select.getPool(),"email",Operator.EQ, email));
			List<UserEmail> oids = select.execute(UserEmail.class);
			int numOids = oids.size();
			
			if (numOids > 0) {
    			SortedSet<Integer> numUsers = new TreeSet<Integer>();
    			for (UserEmail oid: oids){
    				numUsers.add(oid.getUserId());
    			}
    			if (numUsers.size() > 1) {
    				return createLoginView(StatusType.ERROR, "Multiple users associated with same email id");
    			}
				u = Database.getTable(User.class).get(numUsers.first());
			}
			if (u == null){
    			Transaction txn = Database.getInstance().getTransactionManager().createTransaction();
				u = Database.getTable(User.class).newRecord();
    			u.setName(email);
    			u.setPassword(null);
    			u.save();
    			UserEmail oid = Database.getTable(UserEmail.class).newRecord();
    			oid.setUserId(u.getId());
    			oid.setEmail(email);
    			oid.save();
    			txn.commit();
    		}
    		getPath().createUserSession(u, false);
            
			return new RedirectorView(getPath(), loginSuccessful());
		} catch (Exception e) {
			return createLoginView(StatusType.ERROR, e.getMessage());
		}
	}
	
	public static class OidHttpClient implements HttpClient {

	    public OidHttpClient() {
	    }

	    public <T extends OAuthClientResponse>  T execute(OAuthClientRequest request, Map<String, String> headers,
	                                                     String requestMethod, Class<T> responseClass)
	            throws OAuthSystemException, OAuthProblemException {

	        InputStream responseBody = null;
	        URLConnection c;
	        Map<String, List<String>> responseHeaders = new HashMap<String, List<String>>();
	        int responseCode;
	        try {
	            URL url = new URL(request.getLocationUri());

	            c = url.openConnection();
	            c.setConnectTimeout(5000);
	            c.setReadTimeout(5000);
	            responseCode = -1;
	            if (c instanceof HttpURLConnection) {
	                HttpURLConnection httpURLConnection = (HttpURLConnection) c;

	                if (headers != null && !headers.isEmpty()) {
	                    for (Map.Entry<String, String> header : headers.entrySet()) {
	                        httpURLConnection.addRequestProperty(header.getKey(), header.getValue());
	                    }
	                }

	                if (request.getHeaders() != null) {
	                    for (Map.Entry<String, String> header : request.getHeaders().entrySet()) {
	                        httpURLConnection.addRequestProperty(header.getKey(), header.getValue());
	                    }
	                }

	                if (OAuthUtils.isEmpty(requestMethod)) {
	                    httpURLConnection.setRequestMethod(OAuth.HttpMethod.GET);
	                } else {
	                    httpURLConnection.setRequestMethod(requestMethod);
	                    setRequestBody(request, requestMethod, httpURLConnection);
	                }
	                
	                httpURLConnection.connect();

	                InputStream inputStream;
	                responseCode = httpURLConnection.getResponseCode();
	                if (responseCode == SC_BAD_REQUEST || responseCode == SC_UNAUTHORIZED) {
	                    inputStream = httpURLConnection.getErrorStream();
	                } else {
	                    inputStream = httpURLConnection.getInputStream();
	                }

	                responseHeaders = httpURLConnection.getHeaderFields();
	                responseBody = inputStream;
	            }
	        } catch (IOException e) {
	            throw new OAuthSystemException(e);
	        }

	        return OAuthClientResponseFactory
	                .createCustomResponse(responseBody, c.getContentType(), responseCode, responseHeaders, responseClass);
	    }

	    private  void setRequestBody(OAuthClientRequest request, String requestMethod, HttpURLConnection httpURLConnection)
	            throws IOException {
	        String requestBody = request.getBody();
	        if (OAuthUtils.isEmpty(requestBody)) {
	            return;
	        }

	        if (OAuth.HttpMethod.POST.equals(requestMethod) || OAuth.HttpMethod.PUT.equals(requestMethod)) {
	            httpURLConnection.setDoOutput(true);
	            OutputStream ost = httpURLConnection.getOutputStream();
	            PrintWriter pw = new PrintWriter(ost);
	            pw.print(requestBody);
	            pw.flush();
	            pw.close();
	        }
	    }

	    @Override
	    public  void shutdown() {
	        // Nothing to do here
	    }

	}

}
========================================================

import gamification.ExecuteAction;

import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.util.HashMap;
import java.util.Map;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.GitHubTokenResponse;
import org.apache.oltu.oauth2.client.response.OAuthAccessTokenResponse;
import org.apache.oltu.oauth2.client.response.OAuthAuthzResponse;
import org.apache.oltu.oauth2.client.response.OAuthJSONAccessTokenResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.exception.OAuthProblemException;
import org.apache.oltu.oauth2.common.exception.OAuthSystemException;
import org.apache.oltu.oauth2.common.message.types.GrantType;
import org.apache.oltu.oauth2.common.utils.OAuthUtils;
import org.apache.oltu.oauth2.jwt.JWT;
import org.apache.oltu.oauth2.jwt.io.JWTClaimsSetWriter;
import org.apache.oltu.oauth2.jwt.io.JWTHeaderWriter;
import org.apache.oltu.openidconnect.client.response.OpenIdConnectResponse;

import persistency.entities.LoggedUser;
import persistency.exposed.LoggedUserExposed;
import persistency.exposed.UserInfoJson;
import persistency.exposed.LoggedUserExposed.FacebookUserInfoJson;
import persistency.exposed.LoggedUserExposed.LinkedInUserInfoJson;
import service.rest.wrappers.OidClaimSetJsonObject;
import twitter4j.Twitter;
import twitter4j.TwitterException;
import twitter4j.auth.AccessToken;
import twitter4j.auth.RequestToken;
import utils.LoginUtils;
import auth.openidconnect.ApplicationException;
import auth.openidconnect.OAuthParams;
import auth.openidconnect.ProviderData;
import auth.openidconnect.Utils;

import com.google.gson.Gson;

/**
 * Servlet implementation class RedirectServlet
 */
public class RedirectServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected  void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		LoggedUser user = processRequest(request, response);
		ExecuteAction.getInstance().execute("login", user, null);
	}

	private  LoggedUser processRequest(HttpServletRequest request,
			HttpServletResponse response) throws IOException, ServletException {
		LoggedUser user = null;
		if(isAlreadyAuthenticatedThroughClient(request)){
			return authThroughClient(request, response);
		} else {
			Twitter twitter = (Twitter) request.getSession().getAttribute(Utils.TWITTER);
			String provider = null;
			if(twitter != null){
				provider = Utils.TWITTER;
				RequestToken requestToken = (RequestToken) request.getSession().getAttribute("requestToken");
				String verifier = request.getParameter("oauth_verifier");
				if(verifier == null){
					(new Logout()).performLocalInfoRemove(request, response);
					response.sendRedirect("/");
				} else {
					try {
						AccessToken authAccessToken = twitter.getOAuthAccessToken(requestToken, verifier);
						request.getSession().removeAttribute("requestToken");
						user = initOrCreateUserTwitter(request, response, twitter, authAccessToken);
					} catch (TwitterException e) {
						(new Logout()).performLocalInfoRemove(request, response);
						response.sendRedirect("/");
						//					throw new ServletException(e);
					}
				}
			} else{
				OAuthParams oauthParams = new OAuthParams();
				try {
					// Get OAuth Info
					String clientId = LoginUtils.findCookieValue(request, "clientId");
					String clientSecret = LoginUtils.findCookieValue(request, "clientSecret");
					String authzEndpoint = LoginUtils.findCookieValue(request, "authzEndpoint");
					String tokenEndpoint = LoginUtils.findCookieValue(request, "tokenEndpoint");
					String redirectUri = LoginUtils.findCookieValue(request, "redirectUri");
					String scope = LoginUtils.findCookieValue(request, "scope");
					String state = LoginUtils.findCookieValue(request, "state");


					oauthParams.setClientId(clientId);
					oauthParams.setClientSecret(clientSecret);
					oauthParams.setAuthzEndpoint(authzEndpoint);
					oauthParams.setTokenEndpoint(tokenEndpoint);
					oauthParams.setRedirectUri(redirectUri);
					oauthParams.setScope(Utils.isIssued(scope));
					oauthParams.setState(Utils.isIssued(state));

					// Create the response wrapper
					OAuthAuthzResponse oar = null;
					oar = OAuthAuthzResponse.oauthCodeAuthzResponse(request);

					// Get Authorization Code
					String code = oar.getCode();
					oauthParams.setAuthzCode(code);

					String app = LoginUtils.findCookieValue(request, "app");
					response.addCookie(new Cookie("app", app));
					provider = app;
					oauthParams.setApplication(app);
					user = initToken(oauthParams, request, response);
				} catch (OAuthProblemException e) {
					StringBuffer sb = new StringBuffer();
					sb.append("</br>");
					sb.append("Error code: ").append(e.getError()).append("</br>");
					sb.append("Error description: ").append(e.getDescription()).append("</br>");
					sb.append("Error uri: ").append(e.getUri()).append("</br>");
					sb.append("State: ").append(e.getState()).append("</br>");
					oauthParams.setErrorMessage(sb.toString());
//					throw new ServletException(sb.toString(), e);
					e.printStackTrace();
					response.sendRedirect("/");
				} catch (OAuthSystemException e) {
					e.printStackTrace();
					response.sendRedirect("/");
//					throw new ServletException(e);
				}
			}
			createLoginCookie(response, provider);
			response.sendRedirect(request.getContextPath() + "/");
		}
		return user;
	}

	private  void createLoginCookie(HttpServletResponse response, String provider) {
		response.addCookie(new Cookie(Utils.COOKIE_PROVIDER_NAME, provider));

	}

	private  LoggedUser initOrCreateUserTwitter(HttpServletRequest request,
			HttpServletResponse response, Twitter twitter, AccessToken authAccessToken) throws TwitterException, IOException {
		String screenName = twitter.getScreenName();
//		long id = twitter.getId();
		UserInfoJson result = new UserInfoJson();
		result.setEmail(screenName);
		result.setName(screenName+"");
		result.setAccessToken(authAccessToken.getToken());
		result.setSecretAccessToken(authAccessToken.getTokenSecret());
		LoggedUserExposed lue = new LoggedUserExposed();
		LoggedUser findPersonByOpenId = lue.createNewUser(Utils.TWITTER, result);
		//backup 60 min
		findPersonByOpenId.setSessionExpires(System.currentTimeMillis()+60*60*1000);
		lue.updateEntity(findPersonByOpenId);
		LoginUtils.createCookie(response, Utils.TWITTER);
		request.getSession().setAttribute(Utils.ACCESS_TOKEN_SESSION_KEY, findPersonByOpenId.getAccessToken());
		return findPersonByOpenId;
	}

	private  LoggedUser initToken(OAuthParams oauthParams,
			HttpServletRequest req, HttpServletResponse response) throws OAuthSystemException, IOException, ServletException {

		try {

			Utils.validateTokenParams(oauthParams, req.getServerName());

			OAuthClientRequest request = OAuthClientRequest
					.tokenLocation(oauthParams.getTokenEndpoint())
					.setClientId(oauthParams.getClientId())
					.setClientSecret(oauthParams.getClientSecret())
					.setRedirectURI(oauthParams.getRedirectUri())
					.setCode(oauthParams.getAuthzCode())
					.setGrantType(GrantType.AUTHORIZATION_CODE).setParameter(OAuth.OAUTH_ACCESS_TOKEN, oauthParams.getAccessToken())
					.buildBodyMessage();

			URLConnectionClient httpClient = new URLConnectionClient();
			OAuthClient client = new OAuthClient(httpClient);
			String app = LoginUtils.findCookieValue(req, "app");

			OAuthAccessTokenResponse oauthResponse = null;
			Class<? extends OAuthAccessTokenResponse> cl = OAuthJSONAccessTokenResponse.class;

			if (Utils.FACEBOOK.equalsIgnoreCase(app)) {
				cl = GitHubTokenResponse.class;
			} else if (Utils.GOOGLE.equalsIgnoreCase(app)){
				cl = OpenIdConnectResponse.class;
			}
//			initCACerts(app, req);
			oauthResponse = client.accessToken(request, cl);

			oauthParams.setAccessToken(oauthResponse.getAccessToken());

			//dirty workaround
			if(Utils.FACEBOOK.equalsIgnoreCase(app)){
				String[] bodySplit = oauthResponse.getBody().split("&");
				if(bodySplit != null){
					for (String line : bodySplit) {
						if(line != null && line.startsWith("expires=")){
							oauthParams.setExpiresIn(Long.parseLong(line.substring("expires=".length()))*1000);
							break;
						}
					}
				}

			} else {
				oauthParams.setExpiresIn(oauthResponse.getExpiresIn());
			}

			oauthParams.setRefreshToken(Utils.isIssued(oauthResponse.getRefreshToken()));

			if (Utils.GOOGLE.equalsIgnoreCase(app)){
				fetchUserDataFromGoogle(oauthParams, oauthResponse);
			}
			return initOrCreateUser(req, response, oauthParams);
		} catch (ApplicationException e) {
			oauthParams.setErrorMessage(e.getMessage());
			throw new ServletException(e);
		} catch (OAuthProblemException e) {
			StringBuffer sb = new StringBuffer();
			sb.append("</br>");
			sb.append("Error code: ").append(e.getError()).append("</br>");
			sb.append("Error description: ").append(e.getDescription()).append("</br>");
			sb.append("Error uri: ").append(e.getUri()).append("</br>");
			sb.append("State: ").append(e.getState()).append("</br>");
			oauthParams.setErrorMessage(sb.toString());
			throw new ServletException(sb.toString());
		}
	}
	
	
	private  void initCACerts(String app, HttpServletRequest req) {
		KeyStore trustStore;
		try {
			trustStore = KeyStore.getInstance("JKS");
			trustStore.load(req.getServletContext().getResourceAsStream(app+".jks"), "123456".toCharArray());

			KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
			KeyManager[] kms = kmf.getKeyManagers();

			TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
			tmf.init(trustStore);
			TrustManager[] tms = tmf.getTrustManagers();

			SSLContext sslContext = null;
			sslContext = SSLContext.getInstance("TLS");
			sslContext.init(kms, tms, new SecureRandom());

			HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	private  void fetchUserDataFromGoogle(OAuthParams oauthParams,
			OAuthAccessTokenResponse oauthResponse)
					throws MalformedURLException, ServletException {
		OpenIdConnectResponse openIdConnectResponse = ((OpenIdConnectResponse)oauthResponse);
		JWT idToken = openIdConnectResponse.getIdToken();
		oauthParams.setIdToken(idToken.getRawString());

		oauthParams.setHeader(new JWTHeaderWriter().write(idToken.getHeader()));
		oauthParams.setClaimsSet(new JWTClaimsSetWriter().write(idToken.getClaimsSet()));

		URL url = new URL(oauthParams.getTokenEndpoint());

		oauthParams.setIdTokenValid(openIdConnectResponse.checkId(url.getHost(), oauthParams.getClientId()));
		if(!oauthParams.isIdTokenValid()){
			throw new ServletException("Failed to authenticate");
		}
	}

	private  LoggedUser initOrCreateUser(HttpServletRequest request,
			HttpServletResponse response, OAuthParams oauthParams) throws IOException {
		LoggedUserExposed lue = new LoggedUserExposed();
		Gson g = new Gson();
		LoggedUser findPersonByOpenId = null;
		OidClaimSetJsonObject fromJson = null;
		if (oauthParams.getClaimsSet() != null){
			fromJson = g.fromJson(oauthParams.getClaimsSet(), OidClaimSetJsonObject.class);
			findPersonByOpenId = lue.findPersonByOpenId(lue.assebleOpenId(fromJson.getEmail(), oauthParams.getApplication()));
		}
		if(findPersonByOpenId == null){
			String userInfoString = null;
			String userEmail = null;
			try {
				ProviderData data = Utils.getProvider(oauthParams.getApplication(), request);
				userInfoString = getUserInfoString(oauthParams, data.getUserInfoEndpoint());
				if(data.getUserEmailEndpoint() != null){
					userEmail = getUserInfoString(oauthParams, data.getUserEmailEndpoint());
				}
			} catch (OAuthSystemException e) {
				//NO user info can be retrieved
				e.printStackTrace();
			}
			UserInfoJson userInfoJson = null;
			if(userInfoString != null && userInfoString.length() > 0){
				if(oauthParams.getApplication().equalsIgnoreCase(Utils.GOOGLE)){
					userInfoJson = g.fromJson(userInfoString, UserInfoJson.class);
//					if(userInfoJson.getEmail() == null && userInfoJson.getId() != null){
//						userInfoJson.setEmail(userInfoJson.getId());
//					}
				} else if(oauthParams.getApplication().equalsIgnoreCase(Utils.LINKEDIN)){
					userInfoJson = assembleUserInfo(g, userInfoString, userEmail);
				} else if(oauthParams.getApplication().equalsIgnoreCase(Utils.FACEBOOK)){
					userInfoJson = assembleUserInfoFromFacebook(g, userInfoString);
				}
			}
			userInfoJson.setAccessToken(oauthParams.getAccessToken());
			if(userInfoJson.getEmail()== null){
				throw new IllegalArgumentException();
			}
			findPersonByOpenId = lue.createNewUser(oauthParams.getApplication(), userInfoJson);
		}
		if(fromJson != null){
			findPersonByOpenId.setSessionExpires(System.currentTimeMillis() + Long.parseLong(fromJson.getExp()));
		} else if(oauthParams.getExpiresIn() != null) {
			findPersonByOpenId.setSessionExpires(System.currentTimeMillis() + oauthParams.getExpiresIn());
		} else {
			//backup 60 min
			findPersonByOpenId.setSessionExpires(System.currentTimeMillis() + 60*60*1000);
		}
		findPersonByOpenId.setAccessToken(oauthParams.getAccessToken());
		LoginUtils.createCookie(response, oauthParams.getApplication());
		lue.updateEntity(findPersonByOpenId);
		request.getSession().setAttribute(Utils.ACCESS_TOKEN_SESSION_KEY, findPersonByOpenId.getAccessToken());
		return findPersonByOpenId;
	}

	private  UserInfoJson assembleUserInfo(Gson g, String userInfoString,
			String userEmail) {
		LinkedInUserInfoJson userInfoJspon = g.fromJson(userInfoString, LinkedInUserInfoJson.class);
		UserInfoJson result = new UserInfoJson();
		result.setGiven_name(userInfoJspon.getFirstName());
		result.setFamili_name(userInfoJspon.getLastName());
		result.setEmail(userEmail);
		return result;
	}

	private  UserInfoJson assembleUserInfoFromFacebook(Gson g, String userInfoString) {
		FacebookUserInfoJson userInfoJson = g.fromJson(userInfoString, FacebookUserInfoJson.class);
		UserInfoJson result = new UserInfoJson();
		result.setGiven_name(userInfoJson.getFirstName());
		result.setFamili_name(userInfoJson.getLastName());
		result.setName(userInfoJson.getName());
		result.setEmail(userInfoJson.getEmail());
		return result;
	}

	private  String getUserInfoString(OAuthParams oauthParams, String userInfoEndpoint) throws OAuthSystemException {
		OAuthClientRequest request = OAuthClientRequest
				.tokenLocation(userInfoEndpoint)
				.setClientId(oauthParams.getClientId())
				.setClientSecret(oauthParams.getClientSecret())
				.setRedirectURI(oauthParams.getRedirectUri())
				.setCode(oauthParams.getAuthzCode())
				.setGrantType(GrantType.AUTHORIZATION_CODE).setParameter(OAuth.OAUTH_ACCESS_TOKEN, oauthParams.getAccessToken())
				.buildQueryMessage();
		URLConnection c = null;
		int responseCode = 0;
		Map<String, String> headers = new HashMap<String, String>();
		headers.put(OAuth.HeaderType.CONTENT_TYPE, OAuth.ContentType.URL_ENCODED);
		if(oauthParams.getApplication().equalsIgnoreCase(Utils.LINKEDIN)){
			headers.put(OAuth.HeaderType.AUTHORIZATION, "Bearer "+ oauthParams.getAccessToken());
			headers.put("x-li-format", "json");	
		}
		try {
			URL url = new URL(request.getLocationUri());

			c = url.openConnection();
			responseCode = -1;
			if (c instanceof HttpURLConnection) {
				HttpURLConnection httpURLConnection = (HttpURLConnection)c;

				if (headers != null && !headers.isEmpty()) {
					for (Map.Entry<String, String> header : headers.entrySet()) {
						httpURLConnection.addRequestProperty(header.getKey(), header.getValue());
					}
				}

				if (request.getHeaders() != null) {
					for (Map.Entry<String, String> header : request.getHeaders().entrySet()) {
						httpURLConnection.addRequestProperty(header.getKey(), header.getValue());
					}
				}

				httpURLConnection.setRequestMethod(OAuth.HttpMethod.GET);

				httpURLConnection.connect();

				InputStream inputStream;
				responseCode = httpURLConnection.getResponseCode();
				if (responseCode == 400 || responseCode == 401) {
					inputStream = httpURLConnection.getErrorStream();
				} else {
					inputStream = httpURLConnection.getInputStream();
				}

				return OAuthUtils.saveStreamAsString(inputStream);
			}
		} catch (IOException e) {
			throw new OAuthSystemException(e);
		}
		return null;
	}

	private  LoggedUser authThroughClient(HttpServletRequest request, HttpServletResponse response) throws IOException{
		OAuthParams oauthParams = new OAuthParams();
		oauthParams.setAccessToken(request.getHeader(Utils.ACCESS_TOKEN_SESSION_KEY));
		oauthParams.setApplication(request.getHeader("provider"));
		return initOrCreateUser(request, response, oauthParams);	
	}

	private  boolean isAlreadyAuthenticatedThroughClient(HttpServletRequest request){
		return request.getHeader(Utils.ACCESS_TOKEN_SESSION_KEY) != null && request.getHeader("provider") != null; 
	}

}

================================================

/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.airavata.api.server.security.oauth;

import org.apache.airavata.security.AiravataSecurityException;
import org.apache.axis2.AxisFault;
import org.apache.axis2.context.ConfigurationContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.wso2.carbon.identity.oauth2.stub.OAuth2TokenValidationServiceStub;
import org.wso2.carbon.identity.oauth2.stub.dto.OAuth2TokenValidationRequestDTO;
import org.wso2.carbon.identity.oauth2.stub.dto.OAuth2TokenValidationRequestDTO_OAuth2AccessToken;
import org.wso2.carbon.identity.oauth2.stub.dto.OAuth2TokenValidationResponseDTO;
import org.wso2.carbon.utils.CarbonUtils;

import java.rmi.RemoteException;

/**
 * This is the default OAuth Client that talks to WSO2 IS's OAuth Authentication Server
 * to get the OAuth token validated.
 */
public class DefaultOAuthClient {

    private OAuth2TokenValidationServiceStub stub;
    private final static Logger logger = LoggerFactory.getLogger(DefaultOAuthClient.class);
    public static final String BEARER_TOKEN_TYPE = "bearer";

    /**
     * OAuth2TokenValidationService Admin Service Client
     *
     * @param auhorizationServerURL
     * @param username
     * @param password
     * @param configCtx
     * @throws Exception
     */
    public DefaultOAuthClient(String auhorizationServerURL, String username, String password,
                              ConfigurationContext configCtx) throws AiravataSecurityException {
        try {
            String serviceURL = auhorizationServerURL + "OAuth2TokenValidationService";
            stub = new OAuth2TokenValidationServiceStub(configCtx, serviceURL);
            CarbonUtils.setBasicAccessSecurityHeaders(username, password, true, stub._getServiceClient());
        } catch (AxisFault e) {
            logger.error(e.getMessage(), e);
            throw new AiravataSecurityException("Error initializing OAuth client.");
        }
    }

    /**
     * Validates the OAuth 2.0 access token
     *
     * @param accessToken
     * @return
     * @throws Exception
     */
    public  OAuth2TokenValidationResponseDTO validateAccessToken(String accessToken)
            throws AiravataSecurityException {

        try {
            OAuth2TokenValidationRequestDTO oauthReq = new OAuth2TokenValidationRequestDTO();
            OAuth2TokenValidationRequestDTO_OAuth2AccessToken token =
                    new OAuth2TokenValidationRequestDTO_OAuth2AccessToken();
            token.setIdentifier(accessToken);
            token.setTokenType(BEARER_TOKEN_TYPE);
            oauthReq.setAccessToken(token);
            return stub.validate(oauthReq);
        } catch (RemoteException e) {
            logger.error(e.getMessage(), e);
            throw new AiravataSecurityException("Error in validating the OAuth access token.");
        }
    }

}
==============================================

import org.apache.airavata.api.server.security.oauth.DefaultOAuthClient;
import org.apache.airavata.api.server.security.xacml.DefaultXACMLPEP;
import org.apache.airavata.common.utils.Constants;
import org.apache.airavata.model.error.AuthenticationException;
import org.apache.airavata.model.security.AuthzToken;
import org.apache.airavata.security.AiravataSecurityException;
import org.apache.axis2.AxisFault;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.ConfigurationContextFactory;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthResourceResponse;
import org.apache.oltu.oauth2.common.OAuth;
import org.apache.oltu.oauth2.common.message.types.GrantType;
import org.codehaus.jackson.map.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.wso2.carbon.identity.oauth2.stub.dto.OAuth2TokenValidationResponseDTO;

import java.util.HashMap;
import java.util.Map;

public class Main {
    private final static Logger logger = LoggerFactory.getLogger(Main.class);

    private static String username = "scigap_admin";
    private static String password = "sci9067@min";
    private static String hostName = "https://idp.scigap.org:7443";
//    private static String clientId = "KUu0a74dFbrwvSxD3C_GhwKeNrQa";
    private static String clientId = "O3iUdkkVYyHgzWPiVTQpY_tb96Ma";
//    private static String clientSecret = "UTKb9nDOPsuWB4lEX39TwhkW8qIa";
    private static String clientSecret = "6Ck1jZoa2oRtrzodSqkUZ2iINkUa";

    public static  void main(String[] args) throws AuthenticationException, AiravataSecurityException, AxisFault {
        String accessToken = authenticate("master@master.airavata", "master").getAccess_token();
        ConfigurationContext configContext =
                ConfigurationContextFactory.createConfigurationContextFromFileSystem(null, null);
        DefaultOAuthClient defaultOAuthClient = new DefaultOAuthClient(hostName+"/services/",username,password, configContext);
        OAuth2TokenValidationResponseDTO tokenValidationRequestDTO = defaultOAuthClient.validateAccessToken(accessToken);
        String authorizedUser = tokenValidationRequestDTO.getAuthorizedUser();
        AuthzToken authzToken = new AuthzToken();
        authzToken.setAccessToken(accessToken);
        Map<String, String> claimsMap = new HashMap<>();
        claimsMap.put(Constants.USER_NAME, "scigap_admin");
        claimsMap.put(Constants.API_METHOD_NAME, "/airavata/getAPIVersion");
        authzToken.setClaimsMap(claimsMap);

        DefaultXACMLPEP defaultXACMLPEP = new DefaultXACMLPEP(hostName+"/services/",username,password,configContext);
        HashMap<String, String> metaDataMap = new HashMap();
        boolean result = defaultXACMLPEP.getAuthorizationDecision(authzToken, metaDataMap);
        System.out.println(result);
    }

    public static  AuthResponse authenticate(String username,String password) throws AuthenticationException {
        try {
            OAuthClientRequest request = OAuthClientRequest.tokenLocation(hostName+"/oauth2/token").
                    setClientId(clientId).setClientSecret(clientSecret).
                    setGrantType(GrantType.PASSWORD).
                    setRedirectURI("").
                    setUsername(username).
                    setPassword(password).
                    setScope("openid").
                    buildBodyMessage();


            URLConnectionClient ucc = new URLConnectionClient();

            org.apache.oltu.oauth2.client.OAuthClient oAuthClient = new org.apache.oltu.oauth2.client.OAuthClient(ucc);
            OAuthResourceResponse resp = oAuthClient.resource(request, OAuth.HttpMethod.POST, OAuthResourceResponse.class);

            //converting JSON to object
            ObjectMapper mapper = new ObjectMapper();
            AuthResponse authResponse;
            try{
                authResponse = mapper.readValue(resp.getBody(), AuthResponse.class);
            }catch (Exception e){
                return null;
            }

            String accessToken = authResponse.getAccess_token();
            if(accessToken != null && !accessToken.isEmpty()){
                request = new OAuthBearerClientRequest(hostName + "/oauth2/userinfo?schema=openid").
                        buildQueryMessage();
                ucc = new URLConnectionClient();
                request.setHeader("Authorization","Bearer "+accessToken);
                oAuthClient = new org.apache.oltu.oauth2.client.OAuthClient(ucc);
                resp = oAuthClient.resource(request, OAuth.HttpMethod.GET,
                        OAuthResourceResponse.class);
                Map<String,String> profile = mapper.readValue(resp.getBody(), Map.class);
                return authResponse;
            }
        }catch (Exception ex){
            throw new AuthenticationException(ex.getMessage());
        }
        return null;
    }
}

class AuthResponse{

    private String token_type;
    private int expires_in;
    private String refresh_token;
    private String access_token;
    public String id_token;
    private String scope;


    public  String getToken_type() {
        return token_type;
    }

    public  void setToken_type(String token_type) {
        this.token_type = token_type;
    }

    public  int getExpires_in() {
        return expires_in;
    }

    public  void setExpires_in(int expires_in) {
        this.expires_in = expires_in;
    }

    public  String getRefresh_token() {
        return refresh_token;
    }

    public  void setRefresh_token(String refresh_token) {
        this.refresh_token = refresh_token;
    }

    public  String getAccess_token() {
        return access_token;
    }

    public  void setAccess_token(String access_token) {
        this.access_token = access_token;
    }

    public  String getId_token() {
        return id_token;
    }

    public  void setId_token(String id_token) {
        this.id_token = id_token;
    }

    public  String getScope() {
        return scope;
    }

    public  void setScope(String scope) {
        this.scope = scope;
    }
}







====================================================
String auth = key + ":" + secretCombination;

Base64.Encoder encoder = Base64.getEncoder();
String encodedString = encoder.encodeToString(auth.getBytes(StandardCharsets.UTF_8) );

URL url = new URL(path);
HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();
httpCon.setDoInput(true);
httpCon.setDoOutput(true);
httpCon.setRequestMethod("POST");
httpCon.addRequestProperty("Authorization", "Basic " + encodedString);
httpCon.addRequestProperty("Content-Type", "application/x-www-form-urlencoded");

OutputStreamWriter out = new OutputStreamWriter(
httpCon.getOutputStream());
System.out.println(httpCon.getResponseCode());
System.out.println(httpCon.getResponseMessage());


/**
  * To obtain an access token, make an HTTPS request to Amazon
  * and include your client_id and client_secret values.
  */
public String getAuthToken(String clientId, String clientSecret) throws Exception
{
     // Encode the body of your request, including your clientID and clientSecret values.
     String body = "grant_type="    + URLEncoder.encode("client_credentials", "UTF-8") + "&" +
                   "scope="         + URLEncoder.encode("messaging:push", "UTF-8")     + "&" +
                   "client_id="     + URLEncoder.encode(clientId, "UTF-8")             + "&" +
                   "client_secret=" + URLEncoder.encode(clientSecret, "UTF-8");

     // Create a new URL object with the base URL for the access token request.
     URL authUrl = new URL("https://api.amazon.com/auth/O2/token");

     // Generate the HTTPS connection. You cannot make a connection over HTTP.
     HttpsURLConnection con = (HttpsURLConnection) authUrl.openConnection();
     con.setDoOutput( true );
     con.setRequestMethod( "POST" );

     // Set the Content-Type header.
     con.setRequestProperty( "Content-Type" , "application/x-www-form-urlencoded" );
     con.setRequestProperty( "Charset" , "UTF-8" );
     // Send the encoded parameters on the connection.
     OutputStream os = con.getOutputStream();
     os.write(body.getBytes( "UTF-8" ));
     os.flush();
     con.connect();

     // Convert the response into a String object.
     String responseContent = parseResponse(con.getInputStream());

     // Create a new JSONObject to hold the access token and extract
     // the token from the response.
     org.json. JSONObject parsedObject = new org.json.JSONObject(responseContent);
     String accessToken = parsedObject.getString("access_token");
     return accessToken;
}

private String parseResponse(InputStream in) throws Exception
{
     InputStreamReader inputStream = new InputStreamReader(in, "UTF-8" );
     BufferedReader buff = new BufferedReader(inputStream);

     StringBuilder sb = new StringBuilder();
     String line = buff.readLine();
     while (line != null )
     {
       sb.append(line);
       line = buff.readLine();
     }

     return sb.toString();
}


package de.grouponshop.conny.api.example;

public class DocExample {

    // class declaration of AccessToken:
    @org.codehaus.jackson.annotate.JsonIgnoreProperties(ignoreUnknown = true)
    public static class AccessToken {
        public String access_token;
    }

    public static void main(String[] args) {
        // getting the token
        // 1. configure jersey to use the jackson json provider
        com.sun.jersey.api.client.config.ClientConfig cc =
                new com.sun.jersey.api.client.config.DefaultClientConfig();
        cc.getClasses().add(org.codehaus.jackson.jaxrs.JacksonJsonProvider.class);
        com.sun.jersey.api.client.Client client =
                com.sun.jersey.api.client.Client.create(cc);

        // 2. Build parameters to pass to the token creation
        javax.ws.rs.core.MultivaluedMap<String, String> params =
                new com.sun.jersey.core.util.MultivaluedMapImpl();
        params.add("grant_type", "client_credentials");
        params.add("client_id", "YOUR_CLIENT_ID");
        params.add("client_secret", "YOUR_CLIENT_SECRET");

        // 3. make the api-request
        com.sun.jersey.api.client.ClientResponse response = client
                .resource("http://conny.url/api-v1/token")
                .type("application/x-www-form-urlencoded")
                .accept("application/json")
                .post(com.sun.jersey.api.client.ClientResponse.class, params);

        if (response.getStatus() == 201) {
    
            // 4. creation of token successful: get the token-string
            AccessToken tokenObj = response.getEntity(AccessToken.class);
            String token = tokenObj.access_token;
    
            // 5. make an authenticated request
            response = client
                    .resource("http://conny.url/api-v1/product")
                    .accept("application/json")
                    .header(javax.ws.rs.core.HttpHeaders.AUTHORIZATION, "Bearer " + token)
                    .get(com.sun.jersey.api.client.ClientResponse.class);
    
            if (response.getStatus() == 200) {
                System.out.println(response.getEntity(String.class));
            } else {
                System.out.println("Get products failed with status " + response.getStatus());
            }
        } else {
            System.out.println("Authentication failed with status " + response.getStatus());
        }
    }
}













_______________________________________________________________________________________________________
import org.apache.http.HttpHost;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.AuthCache;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.client.BasicAuthCache;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;

/**
 * An example of HttpClient can be customized to authenticate
 * preemptively using BASIC scheme.
 * <b>
 * Generally, preemptive authentication can be considered less
 * secure than a response to an authentication challenge
 * and therefore discouraged.
 * @author Ramesh Fadatare
 */
public class ClientPreemptiveBasicAuthentication {

    public static void main(String[] args) throws Exception {
        HttpHost target = new HttpHost("httpbin.org", 80, "http");
        CredentialsProvider credsProvider = new BasicCredentialsProvider();
        credsProvider.setCredentials(
            new AuthScope(target.getHostName(), target.getPort()),
            new UsernamePasswordCredentials("user", "passwd"));
        CloseableHttpClient httpclient = HttpClients.custom()
            .setDefaultCredentialsProvider(credsProvider).build();
        try {

            // Create AuthCache instance
            AuthCache authCache = new BasicAuthCache();
            // Generate BASIC scheme object and add it to the local
            // auth cache
            BasicScheme basicAuth = new BasicScheme();
            authCache.put(target, basicAuth);

            // Add AuthCache to the execution context
            HttpClientContext localContext = HttpClientContext.create();
            localContext.setAuthCache(authCache);

            HttpGet httpget = new HttpGet("http://httpbin.org/hidden-basic-auth/user/passwd");

            System.out.println("Executing request " + httpget.getRequestLine() + " to target " + target);
            CloseableHttpResponse response = httpclient.execute(target, httpget, localContext);
            try {
                System.out.println("----------------------------------------");
                System.out.println(response.getStatusLine());
                System.out.println(EntityUtils.toString(response.getEntity()));
            } finally {
                response.close();
            }
        } finally {
            httpclient.close();
        }
    }
}








import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpURLConnectionExample {


    public static void main(String[] args) throws Exception {

        // Sending get request
        URL url = new URL("http://example-url");
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();

        conn.setRequestProperty("Authorization","Bearer "+" Actual bearer token issued by provider.");
        //e.g. bearer token= eyJhbGciOiXXXzUxMiJ9.eyJzdWIiOiPyc2hhcm1hQHBsdW1zbGljZS5jb206OjE6OjkwIiwiZXhwIjoxNTM3MzQyNTIxLCJpYXQiOjE1MzY3Mzc3MjF9.O33zP2l_0eDNfcqSQz29jUGJC-_THYsXllrmkFnk85dNRbAw66dyEKBP5dVcFUuNTA8zhA83kk3Y41_qZYx43T

        conn.setRequestProperty("Content-Type","application/json");
        conn.setRequestMethod("GET");


        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String output;

        StringBuffer response = new StringBuffer();
        while ((output = in.readLine()) != null) {
            response.append(output);
        }

        in.close();
        // printing result from response
        System.out.println("Response:-" + response.toString());

    }
}






import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Base64;


public class HttpBasicAuth {

    public static void main(String[] args) {

        try {
            URL url = new URL ("http://ip:port/login");
            String encoding = Base64.getEncoder().encodeToString(("test1:test1").getBytes(‌"UTF‌​-8"​));

            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setRequestProperty  ("Authorization", "Basic " + encoding);
            InputStream content = (InputStream)connection.getInputStream();
            BufferedReader in   = 
                new BufferedReader (new InputStreamReader (content));
            String line;
            while ((line = in.readLine()) != null) {
                System.out.println(line);
            }
        } catch(Exception e) {
            e.printStackTrace();
        }

    }

}

/**
  * To obtain an access token, make an HTTPS request to Amazon
  * and include your client_id and client_secret values.
  */
public String getAuthToken(String clientId, String clientSecret) throws Exception
{
     // Encode the body of your request, including your clientID and clientSecret values.
     String body = "grant_type="    + URLEncoder.encode("client_credentials", "UTF-8") + "&" +
                   "scope="         + URLEncoder.encode("messaging:push", "UTF-8")     + "&" +
                   "client_id="     + URLEncoder.encode(clientId, "UTF-8")             + "&" +
                   "client_secret=" + URLEncoder.encode(clientSecret, "UTF-8");

     // Create a new URL object with the base URL for the access token request.
     URL authUrl = new URL("https://api.amazon.com/auth/O2/token");

     // Generate the HTTPS connection. You cannot make a connection over HTTP.
     HttpsURLConnection con = (HttpsURLConnection) authUrl.openConnection();
     con.setDoOutput( true );
     con.setRequestMethod( "POST" );

     // Set the Content-Type header.
     con.setRequestProperty( "Content-Type" , "application/x-www-form-urlencoded" );
     con.setRequestProperty( "Charset" , "UTF-8" );
     // Send the encoded parameters on the connection.
     OutputStream os = con.getOutputStream();
     os.write(body.getBytes( "UTF-8" ));
     os.flush();
     con.connect();

     // Convert the response into a String object.
     String responseContent = parseResponse(con.getInputStream());

     // Create a new JSONObject to hold the access token and extract
     // the token from the response.
     org.json. JSONObject parsedObject = new org.json.JSONObject(responseContent);
     String accessToken = parsedObject.getString("access_token");
     return accessToken;
}

private String parseResponse(InputStream in) throws Exception
{
     InputStreamReader inputStream = new InputStreamReader(in, "UTF-8" );
     BufferedReader buff = new BufferedReader(inputStream);

     StringBuilder sb = new StringBuilder();
     String line = buff.readLine();
     while (line != null )
     {
       sb.append(line);
       line = buff.readLine();
     }

     return sb.toString();
}


import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Base64;


public class HttpBasicAuth {

    public static void main(String[] args) {

        try {
            URL url = new URL ("http://ip:port/login");
            String encoding = Base64.getEncoder().encodeToString(("test1:test1").getBytes(‌"UTF‌​-8"​));

            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setRequestProperty  ("Authorization", "Basic " + encoding);
            InputStream content = (InputStream)connection.getInputStream();
            BufferedReader in   = 
                new BufferedReader (new InputStreamReader (content));
            String line;
            while ((line = in.readLine()) != null) {
                System.out.println(line);
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
 }
 }


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpURLConnectionExample {


    public static void main(String[] args) throws Exception {

        // Sending get request
        URL url = new URL("http://example-url");
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();

        conn.setRequestProperty("Authorization","Bearer "+" Actual bearer token issued by provider.");
        //e.g. bearer token= eyJhbGciOiXXXzUxMiJ9.eyJzdWIiOiPyc2hhcm1hQHBsdW1zbGljZS5jb206OjE6OjkwIiwiZXhwIjoxNTM3MzQyNTIxLCJpYXQiOjE1MzY3Mzc3MjF9.O33zP2l_0eDNfcqSQz29jUGJC-_THYsXllrmkFnk85dNRbAw66dyEKBP5dVcFUuNTA8zhA83kk3Y41_qZYx43T

        conn.setRequestProperty("Content-Type","application/json");
        conn.setRequestMethod("GET");


        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String output;

        StringBuffer response = new StringBuffer();
        while ((output = in.readLine()) != null) {
            response.append(output);
        }

        in.close();
        // printing result from response
        System.out.println("Response:-" + response.toString());

    }
}

##########################################################################
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

import org.apache.commons.codec.binary.Base64;


public class HttpBasicAuth {

    public static void main(String[] args) {

        try {
            URL url = new URL ("http://ip:port/login");

            Base64 b = new Base64();
            String encoding = b.encodeAsString(new String("test1:test1").getBytes());

            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setRequestProperty  ("Authorization", "Basic " + encoding);
            InputStream content = (InputStream)connection.getInputStream();
            BufferedReader in   = 
                new BufferedReader (new InputStreamReader (content));
            String line;
            while ((line = in.readLine()) != null) {
                System.out.println(line);
            }
        } 
        catch(Exception e) {
            e.printStackTrace();
        }
    }
}



public static void main(String[] args) {
    try {
        DefaultHttpClient Client = new DefaultHttpClient();

        HttpGet httpGet = new HttpGet("https://httpbin.org/basic-auth/user/passwd");
        String encoding = DatatypeConverter.printBase64Binary("user:passwd".getBytes("UTF-8"));
        httpGet.setHeader("Authorization", "Basic " + encoding);

        HttpResponse response = Client.execute(httpGet);

        System.out.println("response = " + response);

        BufferedReader breader = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
        StringBuilder responseString = new StringBuilder();
        String line = "";
        while ((line = breader.readLine()) != null) {
            responseString.append(line);
        }
        breader.close();
        String repsonseStr = responseString.toString();

        System.out.println("repsonseStr = " + repsonseStr);

    } catch (IOException e) {
        e.printStackTrace();
    }

}


public static void main(String[] args) {
    try {
        DefaultHttpClient Client = new DefaultHttpClient();
        Client.getCredentialsProvider().setCredentials(
                AuthScope.ANY,
                new UsernamePasswordCredentials("user", "passwd")
        );

        HttpGet httpGet = new HttpGet("https://httpbin.org/basic-auth/user/passwd");
        HttpResponse response = Client.execute(httpGet);

        System.out.println("response = " + response);

        BufferedReader breader = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
        StringBuilder responseString = new StringBuilder();
        String line = "";
        while ((line = breader.readLine()) != null) {
            responseString.append(line);
        }
        breader.close();
        String responseStr = responseString.toString();
        System.out.println("responseStr = " + responseStr);

    } catch (IOException e) {
        e.printStackTrace();
    }
	
	
	import java.io.IOException;
    import java.io.InputStream;
    import java.io.StringReader;
    import java.util.HashMap;
    import java.util.Map;

    import javax.xml.parsers.DocumentBuilder;
    import javax.xml.parsers.DocumentBuilderFactory;
    import javax.xml.parsers.ParserConfigurationException;

    import org.apache.commons.httpclient.Credentials;
    import org.apache.commons.httpclient.HostConfiguration;
    import org.apache.commons.httpclient.HttpClient;
    import org.apache.commons.httpclient.HttpMethod;
    import org.apache.commons.httpclient.HttpStatus;
    import org.apache.commons.httpclient.UsernamePasswordCredentials;
    import org.apache.commons.httpclient.auth.AuthScope;
    import org.apache.commons.httpclient.methods.GetMethod;
    import org.w3c.dom.*;

    import javax.xml.parsers.*;


    import org.xml.sax.InputSource;
    import org.xml.sax.SAXException;

    public class TestResponse {

    public final static String TESTURL="https://myURL";
    private static final String PROXY_HOST = "www2.proxyXYS";
    private static final int PROXY_PORT = 8080;


    public static void main (String args[]) 
    {
    HttpClient client = new HttpClient();
    HttpMethod method = new GetMethod(TESTURL);
    HostConfiguration config = client.getHostConfiguration();
    config.setProxy(PROXY_HOST, PROXY_PORT);

      String username = "User";
      String password = "Pa55w0rd";


    Credentials credentials = new UsernamePasswordCredentials(username, password);
    AuthScope authScope = new AuthScope(PROXY_HOST, PROXY_PORT);

    client.getState().setProxyCredentials(authScope, credentials);
    client.getState().setCredentials(AuthScope.ANY, credentials);

    try {
        client.executeMethod(method);

        String response = method.getResponseBodyAsString();

        if (method.getStatusCode() == HttpStatus.SC_OK) {
             response = method.getResponseBodyAsString();
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        method.releaseConnection();
    }
}





}
}


 String header = "Basic ";       
    String headerValue = "username" + ":" + "password";
    String encodedHeaderValue = Base64.encodeBase64String(headerValue.getBytes());      
    String headerBasic =  header + encodedHeaderValue;

    Header authHeader = new BasicHeader("Authorization", headerBasic);
      ArrayList<Header> headers = new ArrayList<Header>();
      headers.add(authHeader);  

    ArrayList<Header> headers = getHttpHeaders();
    HttpClient client = HttpClients.custom().setDefaultHeaders(headers).build();

    HttpUriRequest request = RequestBuilder.get().setUri(uri).build();
    HttpResponse response = client.execute(request);

    int responseCode = response.getStatusLine().getStatusCode();




 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import org.apache.http.HttpResponse;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.testng.annotations.Test;
 
/** 
 * This class shows how to perform basic authentication using Apache HttpClient library. 
 * @author Deepak Verma 
 */
public class Basic_Authentication_Apache_HttpClient {
 
    @Test
    public void basicAuthenticate() throws ClientProtocolException, IOException {
 
        String getEndpoint = "http://httpbin.org/basic-auth/user/passwd";
 
        String validUsername = "user";
        String validPassword = "passwd";
 
        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(
            new AuthScope("httpbin.org", 80),
            new UsernamePasswordCredentials(validUsername, validPassword)
        );
 
        CloseableHttpClient httpclient = HttpClients.custom()
            .setDefaultCredentialsProvider(credentialsProvider)
            .build();
 
        HttpGet httpGet = new HttpGet(getEndpoint);
        System.out.println("Executing request " + httpGet.getRequestLine());
 
        HttpResponse response = httpclient.execute(httpGet);
 
        BufferedReader br = new BufferedReader(new InputStreamReader((response.getEntity().getContent())));
 
        //Throw runtime exception if status code isn't 200 
        if (response.getStatusLine().getStatusCode() != 200) {
            throw new RuntimeException("Failed : HTTP error code : " + response.getStatusLine().getStatusCode());
        }
 
        //Create the StringBuffer object and store the response into it. 
        StringBuffer result = new StringBuffer();
        String line = "";
        while ((line = br.readLine()) != null) {
            System.out.println("Response : \n" + result.append(line));
        }
    }
}
 

import java.io.IOException;
import java.io.StringWriter;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.IOUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpException;
import org.apache.http.HttpHost;
import org.apache.http.HttpRequest;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.HttpResponse;
import org.apache.http.auth.AuthScheme;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.AuthState;
import org.apache.http.auth.Credentials;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.protocol.ClientContext;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.junit.Test;


/**
 * Unit test for simple App.
 */
public class AppTest {
	@Test
	public void testApp() throws ClientProtocolException, IOException {
        DefaultHttpClient httpclient = new DefaultHttpClient();
        HttpHost targetHost = new HttpHost("127.0.0.1", 8888, "http"); 
        HttpGet httpget = new HttpGet("/org.drools.guvnor.Guvnor/api/packages/mortgages/toponueva");

        String userPassword = "test" + ":" + "password";
        byte[] encodeBase64 = Base64.encodeBase64(userPassword.getBytes());
		httpget.addHeader("Authorization", "BASIC " + new String(encodeBase64));

        System.out.println("executing request: " + httpget.getRequestLine());
        System.out.println("to target: " + targetHost);
        
        HttpResponse response = httpclient.execute(targetHost, httpget);
        HttpEntity entity = response.getEntity();
        
        StringWriter writer = new StringWriter();
        IOUtils.copy(entity.getContent(), writer);
        System.out.println(writer.toString());

        httpclient.getConnectionManager().shutdown();        
	}
}


/*
 * $Header: 
 * $Revision$
 * $Date$
 * ====================================================================
 *
 *  Copyright 1999-2004 The Apache Software Foundation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * [Additional notices, if required by prior licensing conditions]
 *
 */
 
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.UsernamePasswordCredentials;
import org.apache.commons.httpclient.auth.AuthScope;
import org.apache.commons.httpclient.methods.GetMethod;
 
/**
 * A simple example that uses HttpClient to perform a GET using Basic
 * Authentication. Can be run standalone without parameters.
 *
 * You need to have JSSE on your classpath for JDK prior to 1.4
 *
 * @author Michael Becke
 */
public class BasicAuthenticationExample {
     
    /**
     * Constructor for BasicAuthenticatonExample.
     */
    public BasicAuthenticationExample() {
        super();
    }
     
    public static void main(String[] args) throws Exception {
        HttpClient client = new HttpClient();
         
        // pass our credentials to HttpClient, they will only be used for
        // authenticating to servers with realm "realm" on the host
        // "www.verisign.com", to authenticate against an arbitrary realm 
        // or host change the appropriate argument to null.
        client.getState().setCredentials(
                new AuthScope("www.verisign.com", 443, "realm"),
                new UsernamePasswordCredentials("username", "password")
                );
         
        // create a GET method that reads a file over HTTPS, 
        // we're assuming that this file requires basic 
        // authentication using the realm above.
        GetMethod get = new GetMethod(
                "https://www.verisign.com/products/index.html");
         
        // Tell the GET method to automatically handle authentication. The
        // method will use any appropriate credentials to handle basic
        // authentication requests.  Setting this value to false will cause
        // any request for authentication to return with a status of 401.
        // It will then be up to the client to handle the authentication.
        get.setDoAuthentication( true );
         
        try {
            // execute the GET
            int status = client.executeMethod( get );
             
            // print the status and response
            System.out.println(status + "\n" + 
                    get.getResponseBodyAsString());
             
        } finally {
            // release any connection resources used by the method
            get.releaseConnection();
        }
    }
}



CredentialsProvider provider = new BasicCredentialsProvider();
UsernamePasswordCredentials credentials = new UsernamePasswordCredentials("user1", "user1Pass");
provider.setCredentials(AuthScope.ANY, credentials);
HttpClient client = HttpClientBuilder.create().setDefaultCredentialsProvider(provider).build();

HttpResponse response = client.execute(new HttpGet(URL_SECURED_BY_BASIC_AUTHENTICATION));
int statusCode = response.getStatusLine().getStatusCode();
assertThat(statusCode, equalTo(HttpStatus.SC_OK));

HttpHost targetHost = new HttpHost("localhost", 8080, "http");
CredentialsProvider credsProvider = new BasicCredentialsProvider();
credsProvider.setCredentials(AuthScope.ANY, 
  new UsernamePasswordCredentials(DEFAULT_USER, DEFAULT_PASS));

AuthCache authCache = new BasicAuthCache();
authCache.put(targetHost, new BasicScheme());

// Add AuthCache to the execution context
final HttpClientContext context = HttpClientContext.create();
context.setCredentialsProvider(credsProvider);
context.setAuthCache(authCache);

HttpClient client = HttpClientBuilder.create().build();
response = client.execute(new HttpGet(URL_SECURED_BY_BASIC_AUTHENTICATION), context);

int statusCode = response.getStatusLine().getStatusCode();
assertThat(statusCode, equalTo(HttpStatus.SC_OK));


HttpGet request = new HttpGet(URL_SECURED_BY_BASIC_AUTHENTICATION);
String auth = DEFAULT_USER + ":" + DEFAULT_PASS;
byte[] encodedAuth = Base64.encodeBase64(auth.getBytes(Charset.forName("US-ASCII")));
String authHeader = "Basic " + new String(encodedAuth);
request.setHeader(HttpHeaders.AUTHORIZATION, authHeader);

HttpClient client = HttpClientBuilder.create().build();
HttpResponse response = client.execute(request);

int statusCode = response.getStatusLine().getStatusCode();
assertThat(statusCode, equalTo(HttpStatus.SC_OK));

String encoding = Base64Encoder.encode(user + ":" + pwd);
HttpPost httpPost = new HttpPost("http://host:post/test/login");
httpPost.setHeader(HttpHeaders.AUTHORIZATION, "Basic " + encoding);

System.out.println("executing request " + httpPost.getRequestLine());
HttpResponse response = httpClient.execute(httpPost);
HttpEntity entity = response.getEntity();


import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Base64;

import org.apache.commons.io.IOUtils;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.HttpClientBuilder;

public class OAuthClient {

private String tokenEndpoint = "https://oauthasservices-   
                                <subaccountuser>.[xxx.]hana.ondemand.com/oauth2/api/v1/token";
	private String client_id = "myclient_id";
	private String client_secret = "mysecret";
	private String grant_type = "client_credentials";
	private String scope = "generate-ads-output";

	public String callService() {

		/* HTTPCLIENT AND HTTPPOST OOBJECT */
		HttpClient httpClient = HttpClientBuilder.create().build();
		HttpPost httpPost = new HttpPost(tokenEndpoint);

		/* AUTHENTICATION CREDENTIALS ENCODING */
		String base64Credentials = Base64.getEncoder().encodeToString((client_id + ":" 
                                              + client_secret).getBytes());

		/* HEADER INFO */
		httpPost.addHeader("Authorization", "Basic " + base64Credentials);
		httpPost.addHeader("Content-Type", "application/x-www-form-urlencoded");

		/* PROXY CONFIG */
		HttpHost target = new HttpHost("proxy", 8080, "http");
		RequestConfig config = RequestConfig.custom().setProxy(target).build();
		httpPost.setConfig(config);

		/* OAUTH PARAMETERS ADDED TO BODY */
		StringEntity input = null;
		try {
			input = new StringEntity("grant_type=" + grant_type + "&scope=" + scope);
			httpPost.setEntity(input);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}

		/* SEND AND RETRIEVE RESPONSE */
		HttpResponse response = null;
		try {
			response = httpClient.execute(httpPost);
		} catch (IOException e) {
			e.printStackTrace();
		}

		/* RESPONSE AS STRING */
		String result = null;
		try {
			result = IOUtils.toString(response.getEntity().getContent(), "UTF-8");
		} catch (IOException e) {
			e.printStackTrace();
		}

		return result;
	}

	public static void main(String[] args) {
		OAuthClient oauthClient = new OAuthClient();
		String res = oauthClient.callService();
		System.out.println(res);
	}
}
